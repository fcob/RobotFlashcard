(*-----------------------------------------------------------------------------
*                             (c) 2002 by KEBA AG
*                                Linz/AUSTRIA
*                             All rights reserved
*------------------------------------------------------------------------------
*  Component    : Rcu
*  Modul        : Ecotalk.ttp
*  First Author : pen
*  Date         : 27.6.2002
*------------------------------------------------------------------------------
*  Description:
*
*  User-Layer with macros for multiple kinematics, non-ambiguous relation
* between flow and kinematic is needed
*------------------------------------------------------------------------------
* 13.08.04 nmr: RSELECT: gRcuKinList[i].kin.Select(); instead of SELECT 
*               gRcuKinList[i].kin Reason: the Select() Routine should always be
*               used, because it checks if a kinematic is already selected. If a
*               kinematic is already selected an Error will be set and both
*               programs will be stopped. Using SELECT the program which wants
*               to select a kinematic waits until the program which has selected
*               the kinematic releases the kinematic, only now the the second program
*               starts moving.
* 19.08.04 nmr: Bug in RSELECT and RDESELECT fixed. (Endless loop).
*               Consideration of Frame-Types in SETTOOL and SETOBJECT similar to
*               M_SETTOOL and M_SETOBJECT.
* 11.11.04 BMA: More affinity to EcoTalk (old)
*               These macros are changed: 
*                 - PTP
*                 - LIN
*                 - CIRC
*                 - VEL
*                 - JERK
*                 - OVERLAP
*                 - SETTOOL
*                 - GUN
*                 - SETBRUSH
*                 - SETOBJECT
*                 - DELAY
*               New macros:
*                 - ACC
*                 - RAMP
*                 - RECEIVE
*                 - SET
*
* 18.03.05 BMA: Old and unused macros removed.
* 23.05.05 sbj: Following Handler-macros included:
*               RECEIVE_ORDER, SET_ORDER, RECEIVE_HANDLERPOS
* 24.05.05 BIT: Following Handlertool-macros included:
*               SET_SENSOR, SET_CHECK, GET_PART
* 03.06.05 BMA: SET and RECEIVE with WAIT MAIN_RUN
*               SETMR new (Output is activated in mainrun without stopping the prerun
* 11.07.05 BMA: Modification in routine DELAY because of strange type extend in 
*               assignments
* 27.07.05 BMA: SETOBJECT for tracking
* 26.08.05 nmr: modification for new vision-mask in SETOBJECT
* 08.09.05 nmr: changes for Teachview 2.16
* 15.09.05 nmr: changes for new Vision-Mask
* 03.11.05 sbj: changed second parameter of OvlCart from 1.0 to 10.0
* 01.12.05 BMA: modifications for tracking (motion buffer) in MAINRUN().
*               "WAIT MAIN_RUN" and "MAINRUN()" now are different. MAINRUN() has
*               to be used if the robot movement should stop, e.g. DELAY or
*               RECEIVE. WAIT MAINRUN has to be used if a coroutine needs a signal
*               when the mainrun passes a point on the path.
* 20.01.06 BMA: Actual TCP Position and actual Object to Systemvariables
* 26.07.06 BIT: changes at handlermacros
* 06.11.06 BMA: New macros SHIFT and RESHIFT
* 20.11.06 BMA: macros for tracking added
*)


(*******************************************************************************
* globals
*)

// --------------------- E C O T A L K -----------------------------------------
TYPE GLOBAL USER
   IOTYPE : (High, Low, Data);
   
   UNIT  : (Unit1, Unit2, Unit3, Unit4, Unit5);
   ORDER : (Calibrate, Gain, MaxLimit, MaxLimitOff, MinLimit, MinLimitOff, SearchCycle, CheckPart, Stop);
   GAIN  : (c7_5, c15_0, c30_0, c60_0, cUndef, cHard, cFine);
   INTERPOLATIONTYPE : (WRISTJOINT, ZROTATION, ZROTATIONCIRC);
//   TRcuTrackingCmd : (On, Off, Finished, Resume);
   TRcuTrackingCmd : (Off, On, Resume, Finished);
   TRcuTrackingMode: (LineTracking, RailTracking);
   TRcuGreaterSmaller : (GREATER, SMALLER, EQUAL);
   
   TRcuPreMainRun   : (MainRun, PreRun, Stopp);
   TRcuMotionGroup  : (InBellCleaner, InCapCleaner, HomingActive, GrindBrake, TorqueMon, BrakeCheck);
   TRcuMotionJob    : (Robot, True, False, Joint1, Joint2, Joint3, Joint4, Joint5, Joint6, Joint7, Joint8, Joint9);
   TRcuProcessGroup : (Hightension, GoHomeAtEnd, NoPaint, AbortBody, PistonChange, TankStop,
                       MD_InUse, MD_DeskOrder, MD_Cover, MD_Coupling, MD_MaskGripper, MD_AtIni, PivotingBracketInPos);
   TRcuProcessJob   : (ON, OFF, CouplingErrorOn, CouplingErrorOff);
   TRcuProcessGroup_BCC : (ToolDeskStatus, Couple, Uncouple,Lift, Lower, PrcStart, PrcDone, Collision, CheckNozzle, CheckAllNozzles);
   TRcuProcessGroup_PI : (PlacePlug, CheckPlug, StartFilling, FillingDone, Couple_PI, Uncouple_PI, ToolDeskStatus_PI, Collision_PI, GetPlug, DiscargePlugMagazin, PlugCheck, PlugMagazinDischarged); 
   DATARECORDINGCMD : (REC_ON, REC_OFF);
   TORQUEORDER : (ObserveMaxLimit, ObserveMinLimit, PartDetectPosDir, PartDetectNegDir);
   TORQUECHECK : (StartCheck, StopCheck);
   STARTSTOP : (StartLogging , StopLogging);
   AXISNAME : (Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7, Axis8, Axis9);
   APP_POS : (Undef := 0, Vertical :=1, Pivot:=2, ValvesOff := 3);  // Gluing: Postion of the applicator ("Schwenkantrieb" SA) 
   PACCCOMMAND :  (Enable, Disable, WriteFile, AllPoints, OneShot);
   BK_MODE_TYPE : (ModeMeasure := 1, ModeApplication := 2, Mode_MP_Ref := 11, Mode_PP_Ref := 12, Mode_ApplTest := 20, Mode_Off := 99);
   TVisionSubSystemType : (Absolute := 1, Relative:= 2);
   TRcuHandlerState : (IsNotHandler, IsHandler);
   TRcuFunctionUnit : (PCUx, RCUx, BCUx, FUsystem);
   TRcuResetAtProgEnd : (ResetAtProgEnd, NoResetAtProgEnd);
   NC_ErrorCase : (NoPlaceToStore, NoNozzleToTake);
   NC_Switch : (AirOn, AirOff);
   NC_State : (StateOK, StateNOK);
END_TYPE


TYPE GLOBAL USER 
   SplineType : (CubicBessel := 2, CubicAkima, Line);
END_TYPE


(******************************************************************************************************************
******************   Group  MOVEMENT in Teachview - menu  *********************************************************
******************************************************************************************************************)

// --------------------- E C O T A L K -----------------------------------------
// Move to a point using axes-interpolation
ROUTINE PTP(point : POINT) GLOBAL USER { macro="MOVEMENT" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "PTP") THEN
      IF elem.kin.homing.SimulateMacro("PTP") THEN
         elem.kin.homing.SetLastTarget(point);
         RETURN;
      END_IF;
      
      elem.kin.progPath.Ptp(point);
   END_IF;
END_ROUTINE


// --------------------- E C O T A L K -----------------------------------------
// Move to a point using axes-interpolation
ROUTINE PTP_MODE(point : POINT_M) GLOBAL USER { macro="MOVEMENT" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "PTP_MODE") THEN
      IF elem.kin.homing.SimulateMacro("PTP_MODE") THEN
         elem.kin.homing.SetLastTarget(point);
         RETURN;
      END_IF;
      
      elem.kin.progPath.Ptp(point);
   END_IF;
END_ROUTINE


(*
// --------------------- E C O T A L K -----------------------------------------
// Move to a point using axes-interpolation. Tracking!
ROUTINE PTP_ABS(point : POINT) GLOBAL USER { macro="MOVEMENT" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem) THEN
      point.PointPtpAbs(elem);
   END_IF;
END_ROUTINE
*)

// --------------------- E C O T A L K -----------------------------------------
// Move to a point using cartesian interpolation
ROUTINE LIN(point : POINT) GLOBAL USER { macro="MOVEMENT" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "LIN") THEN
      IF elem.kin.homing.SimulateMacro("LIN") THEN
         elem.kin.homing.SetLastTarget(point);
         RETURN;
      END_IF;
      
      elem.kin.progPath.Lin(point);
   END_IF;
END_ROUTINE


// --------------------- E C O T A L K -----------------------------------------
// move on a circle-segment
ROUTINE CIRC(helpPoint : POINT; point : POINT) GLOBAL USER { macro="MOVEMENT" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR

   IF RcData.CheckKin(elem, "CIRC") THEN
      IF elem.kin.homing.SimulateMacro("CIRC") THEN
         elem.kin.homing.SetLastTarget(point);
         RETURN;
      END_IF;
      IF elem.kin.homing.bHomingOnCirc THEN
         elem.kin.homing.MoveCirc(helpPoint, point);
      ELSE
         elem.kin.progPath.Circ(helpPoint, point);
      END_IF;
   END_IF;
END_ROUTINE


(*$$$$$* spline *$$$$$*)             
// --------------------- E C O T A L K -----------------------------------------
// move on a spline
// a spline is a multi-segment object, with spline-segment you can add one part of a spline
ROUTINE SPLINE_START_TANG(splinePoint : POINT; 
                          VAR_IN param : REAL; 
                          VAR_IN type : SplineType;
                          tangentPoint : POINT) GLOBAL USER { macro="MOVEMENT" | enable="_system.gRcuFocusedRobot.bEnableSpline" }
   VAR
      elem   : TRcuKinListElem; // element with the kinematicreference
      p : REAL := 1.0;
      t : TMcuSplineDefType := eMcuSplineCubicAkima;
   END_VAR

   IF RcData.CheckKin(elem, "SPLINE_START_TANG") THEN
      IF NOT (elem.kin.bEnableSpline) THEN
         STOPPOINT();
         RcuSetMessageOnce(EcoTalk_ErrSplineNotEnabled, elem.kin.kinListInx, 1, 0, "EcoTalk.SPLINE_START_TANG", "SPLINE_START_TANG");
         elem.kin.ErrorReaction(TRUE);
         RETURN;
      END_IF;
      IF elem.kin.homing.SimulateMacro("SPLINE_START_TANG") THEN
         elem.kin.homing.SetLastTarget(splinePoint);
         RETURN;
      END_IF;
      
      p := param;
      t := TMcuSplineDefType(type);
      elem.kin.progPath.Spline(splinePoint, p, t, FALSE, tangentPoint);
   END_IF;
END_ROUTINE

ROUTINE SPLINE(splinePoint : POINT; 
               VAR_IN param : REAL; 
               VAR_IN type : SplineType) GLOBAL USER { macro="MOVEMENT" | enable="_system.gRcuFocusedRobot.bEnableSpline" }
   VAR
      elem   : TRcuKinListElem; // element with the kinematicreference
      p : REAL := 1.0;
      t : TMcuSplineDefType := eMcuSplineCubicAkima;
   END_VAR

   IF RcData.CheckKin(elem, "SPLINE") THEN
      IF NOT (elem.kin.bEnableSpline) THEN
         STOPPOINT();
         RcuSetMessageOnce(EcoTalk_ErrSplineNotEnabled, elem.kin.kinListInx, 2, 0, "EcoTalk.SPLINE", "SPLINE");
         elem.kin.ErrorReaction(TRUE);
         RETURN;
      END_IF;
      IF elem.kin.homing.SimulateMacro("SPLINE") THEN
         elem.kin.homing.SetLastTarget(splinePoint);
         RETURN;
      END_IF;
      
      p := param;
      t := TMcuSplineDefType(type);
      elem.kin.progPath.Spline(splinePoint, p, t, FALSE);
   END_IF;
END_ROUTINE

ROUTINE SPLINE_END() GLOBAL USER { macro="MOVEMENT" | enable="_system.gRcuFocusedRobot.bEnableSpline" }
   VAR
      elem   : TRcuKinListElem; // element with the kinematicreference
   END_VAR

   IF RcData.CheckKin(elem, "SPLINE_END") THEN
      IF NOT (elem.kin.bEnableSpline) THEN
         STOPPOINT();
         RcuSetMessageOnce(EcoTalk_ErrSplineNotEnabled, elem.kin.kinListInx, 3, 0, "EcoTalk.SPLINE_END", "SPLINE_END");
         elem.kin.ErrorReaction(TRUE);
         RETURN;
      END_IF;
      IF elem.kin.homing.SimulateMacro("SPLINE_END") THEN
         RETURN;
      END_IF;
      
      elem.kin.progPath.EndSpline();
   END_IF;
END_ROUTINE

ROUTINE SPLINE_END_TANG(splinePoint : POINT; 
                         VAR_IN param : REAL; 
                         VAR_IN type : SplineType;
                         tangentPoint : POINT) GLOBAL USER { macro="MOVEMENT" | enable="_system.gRcuFocusedRobot.bEnableSpline" }
   VAR
      elem   : TRcuKinListElem; // element with the kinematicreference
      p : REAL := 1.0;
      t : TMcuSplineDefType := eMcuSplineCubicAkima;
   END_VAR

   IF RcData.CheckKin(elem, "SPLINE_END_TANG") THEN
      IF NOT (elem.kin.bEnableSpline) THEN
         STOPPOINT();
         RcuSetMessageOnce(EcoTalk_ErrSplineNotEnabled, elem.kin.kinListInx, 4, 0, "EcoTalk.SPLINE_END_TANG", "SPLINE_END_TANG");
         elem.kin.ErrorReaction(TRUE);
         RETURN;
      END_IF;
      IF elem.kin.homing.SimulateMacro("SPLINE_END_TANG") THEN
         elem.kin.homing.SetLastTarget(splinePoint);
         RETURN;
      END_IF;
      
      p := param;
      t := TMcuSplineDefType(type);
      elem.kin.progPath.Spline(splinePoint, p, t,TRUE, tangentPoint);
      elem.kin.progPath.EndSpline();
   END_IF;
END_ROUTINE


// --------------------- E C O T A L K -----------------------------------------
// Shift the following points
ROUTINE SHIFT(Shift : SSHIFT) GLOBAL USER { macro="MOVEMENT" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "SHIFT") THEN
      elem.kin.ActShift := Shift;
      START ShiftInMainrun(elem.kin, Shift);
   END_IF;
END_ROUTINE


// Shift the following points
ROUTINE ShiftInMainrun(kin : TRcuKinematic; Shift : SSHIFT)
   VAR
      lShift: SSHIFT;
      lKin  : MAPTO TRcuKinematic;
   END_VAR
   
   lShift := Shift;
   lKin   := MAP(kin);
   MAINRUN();
   lKin.ActMRShift := lShift;
END_ROUTINE


// --------------------- E C O T A L K -----------------------------------------
// End of shifting
ROUTINE RESHIFT() GLOBAL USER { macro="MOVEMENT" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
      ActShift : SSHIFT;
   END_VAR
   
   IF RcData.CheckKin(elem, "RESHIFT") THEN
      ActShift.A7_mm := 0.0;
      ActShift.X_mm  := 0.0;
      ActShift.Y_mm  := 0.0;
      ActShift.Z_mm  := 0.0;
      elem.kin.ActShift := ActShift;
      START ShiftInMainrun(elem.kin, ActShift);
   END_IF;
END_ROUTINE

// Shift the following points
ROUTINE SHIFT_EXT(ShiftExt : SSHIFT_EXT) GLOBAL USER { macro="MOVEMENT" | enable="_system.gRcuFocusedRobot.bEnableShiftExt"}
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "SHIFT_EXT") THEN
      elem.kin.ActShiftExt := ShiftExt;
      START ShiftExtInMainrun(elem.kin, ShiftExt);
   END_IF;
END_ROUTINE


// Shift the following points
ROUTINE ShiftExtInMainrun(kin : TRcuKinematic; ShiftExt : SSHIFT_EXT)
   VAR
      lShiftExt : SSHIFT_EXT;
      lKin      : MAPTO TRcuKinematic;
   END_VAR
   
   lShiftExt := ShiftExt;
   lKin      := MAP(kin);
   MAINRUN();
   lKin.ActMRShiftExt := lShiftExt;
END_ROUTINE


// --------------------- E C O T A L K -----------------------------------------
// End of shifting
ROUTINE RESHIFT_EXT() GLOBAL USER { macro="MOVEMENT" | enable="_system.gRcuFocusedRobot.bEnableShiftExt"}
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
      ActShiftExt : SSHIFT_EXT;
   END_VAR
   
   IF RcData.CheckKin(elem, "RESHIFT_EXT") THEN
      ActShiftExt.A7_mm  := 0.0;
      ActShiftExt.A8_deg := 0.0;
      ActShiftExt.A9_deg := 0.0;
      ActShiftExt.X_mm   := 0.0;
      ActShiftExt.Y_mm   := 0.0;
      ActShiftExt.Z_mm   := 0.0;
      elem.kin.ActShiftExt := ActShiftExt;
      START ShiftExtInMainrun(elem.kin, ActShiftExt);
   END_IF;
END_ROUTINE


(******************************************************************************************************************
******************   Group  DYNAMIC in Teachview - menu  **********************************************************
******************************************************************************************************************)

// --------------------- E C O T A L K -----------------------------------------
// set the joint-velocity in percent of the limiting values
ROUTINE VEL(x : VELOCITY) GLOBAL USER { macro="DYNAMIC" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR

   IF RcData.CheckKin(elem, "VEL") THEN
      // set the joint-velocity in percent of the limiting values
      elem.kin.progPath.Vel(x.PTP_PERC);
      // set the cartesian velocity in m/s
      elem.kin.progPath.PathVel(x.Path_Val);
      IF elem.kin.bBeforeFirstMove THEN
         elem.kin.rActProgVelocity := x.Path_Val;
      ELSE
         // rActProgVelocity in mainrun
         START elem.kin.SetVelocityInMainRun(x.Path_Val);
      END_IF;
      // set the turn-velocity in degrees/s
      elem.kin.progPath.TurnVel(x.Rot_Val);
   END_IF;
END_ROUTINE


// --------------------- E C O T A L K -----------------------------------------
// set the acceleration
ROUTINE ACC(x: ACCELERATION) GLOBAL USER { macro="DYNAMIC" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR

   IF RcData.CheckKin(elem, "ACC") THEN
      elem.kin.progPath.Accel(x.PTP_PERC, x.PTP_PERC);
      elem.kin.progPath.PathAccel(x.Path_Acc, x.Path_Dcc);
      elem.kin.progPath.TurnAccel(x.Rot_Val, x.Rot_Val);
   END_IF;
END_ROUTINE


// --------------------- E C O T A L K -----------------------------------------
// set the joint-jerk (xJerk) in percent of
// the limiting values
ROUTINE JERK(x : JERKDCL) GLOBAL USER { macro="DYNAMIC" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR

IF RcData.CheckKin(elem, "JERK") THEN
      elem.kin.progPath.Jerk(x.PTP_PERC);
      elem.kin.progPath.PathJerk(x.Path_Val);
      elem.kin.progPath.TurnJerk(x.Rot_Val);
   END_IF;
END_ROUTINE

// --------------------- E C O T A L K -----------------------------------------
// set acceleration ramp
ROUTINE RAMP(x : RAMPDCL) GLOBAL USER { macro="DYNAMIC" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
      type : TMcuRampTyp;
      param : REAL; 
      param2 : REAL;
   END_VAR

   IF RcData.CheckKin(elem, "RAMP") THEN
      CASE x.RampType OF
      Trapez    : type := eMcuTrapez;
                  param := x.RampFactor;
                  param2 := x.RampFactor;
      SinusQuad : type := eMcuSinusQuadrat;
                  param := x.RampFactor;
                  param2 := 0.0;
      Triangle  : type := eMcuTrapez;
                  param := 0.5;
                  param2 := 0.5;
      END_CASE;
      elem.kin.progPath.AcceRamp(type, param, param2);
      elem.kin.progPath.DeceRamp(type, param, param2);
   END_IF;
END_ROUTINE

(******************************************************************************************************************
******************   Group  GEOMETRIC in Teachview - menu  ********************************************************
******************************************************************************************************************)

// --------------------- E C O T A L K -----------------------------------------
// set overlap-type and -parameters, generic interface
//ROUTINE OVERLAP(type : TMcuOvlTyp; defType : TMcuOvlDefTyp; paramPrev : REAL; paramThis : REAL) GLOBAL USER
ROUTINE OVERLAP(Overlap : OVERLAPDCL) GLOBAL USER { macro="GEOMETRIC" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
      cnt : DINT;
   END_VAR
   
   IF RcData.CheckKin(elem, "OVERLAP") THEN
      CASE Overlap.Mode OF
         Fine     : elem.kin.progPath.OvlNone();
         Vel      : elem.kin.progPath.OvlDynVelo(Overlap.Vel_Perc);
         Pos      : elem.kin.progPath.OvlCartAcc(Overlap.Path_Val, Overlap.Vel_Perc );
         ConstPos : RcuSetMessageOnce(EcoTalk_WarOvlTypeNotImpl, elem.kin.kinListInx, 2, 0, "Ecotalk.OVERLAP", "ConstPos");
         Cart     : elem.kin.progPath.OvlCart(Overlap.Path_Val, 10.0);
         PTPVel   : RcuSetMessageOnce(EcoTalk_WarOvlTypeNotImpl, elem.kin.kinListInx, 3, 0, "Ecotalk.OVERLAP", "PTPVel");
      ELSE
         RcuSetMessageOnce(EcoTalk_WarOvpUnknown, elem.kin.kinListInx, 1, 0, "Ecotalk.OVERLAP");
      END_CASE;
      // elem.kin.progPath.Overlap(type, defType, paramPrev, paramThis);
      // wait for next tick to avoid a jitter in program execution
      // because of not reproducible points of interrupt by higher prior tasks
      cnt := elem.kin.actExecData.mUpdateCounterMain;
      WAIT cnt <> elem.kin.actExecData.mUpdateCounterMain;
      IF gDoRuntimeVerification THEN
          RuntimeVerification(elem.kin, "OVERLAP", 19, FALSE, 0);
      END_IF;
   END_IF;
END_ROUTINE

// --------------------- E C O T A L K -----------------------------------------
// 13-11-2003 Bauder
// change the object coordinate system
// 19.08.2004 nmr
// Consider the Frame-Types according to M_SETOBJECT  
// orientation : kardan-angles
ROUTINE SETOBJECT(object : OBJECT) GLOBAL USER { macro="GEOMETRIC" }
   VAR
      frame : TMcuFrame;
      elem : TRcuKinListElem; // element with the kinematicreference
      cnt : DINT;
      s : STRING;
   END_VAR

   frame.mPos.mValues[0] := object.X_mm;
   frame.mPos.mValues[1] := object.Y_mm;
   frame.mPos.mValues[2] := object.Z_mm;
   frame.mOri.mValues[0] := object.A_deg;
   frame.mOri.mValues[1] := object.B_deg;
   frame.mOri.mValues[2] := object.C_deg;
   frame.mFrameTyp := eMcuFrameKardan;
   IF gMcuFrameTyp = eMcuFrameEuler THEN
      RcuSetMessageOnce(EcoTalk_WarWrongTypeOfFrame, elem.kin.kinListInx, 2, 0, "Ecotalk.SETOBJECT");
   END_IF;

   IF RcData.CheckKin(elem, "SETOBJECT") THEN
      // wait for next tick to avoid a jitter in program execution
      // because of not reproducible points of interrupt by higher prior tasks
      cnt := elem.kin.actExecData.mUpdateCounterMain;
      WAIT cnt <> elem.kin.actExecData.mUpdateCounterMain;
      IF gDoRuntimeVerification THEN
          RuntimeVerification(elem.kin, "SETOBJECT", 19, FALSE, 0);
      END_IF;
      s := object.GetName();
      elem.kin.SetObject(s, frame);
      // wait for next tick to avoid a jitter in program execution
      // because of not reproducible points of interrupt by higher prior tasks
      cnt := elem.kin.actExecData.mUpdateCounterMain;
      WAIT cnt <> elem.kin.actExecData.mUpdateCounterMain;
      IF gDoRuntimeVerification THEN
         RuntimeVerification(elem.kin, "SETOBJECT", 19, FALSE, 0);
      END_IF;
      elem.kin.vision.SetActualObject(object);
   END_IF;
END_ROUTINE

// --------------------- E C O T A L K -----------------------------------------
// Set a tool for the kinematic
// Orientation : kardan-angles
// 19.08.2004 nmr
// Consider the Frame-Types according to M_SETTOOL
ROUTINE SETTOOL(Tool : TOOL) GLOBAL USER { macro="GEOMETRIC" }
   VAR
      kardanFrame : TMcuFrame;
      frame : TMcuFrame;
      elem : TRcuKinListElem; // element with the kinematicreference
      s : STRING;
   END_VAR
   
   kardanFrame.mFrameTyp := eMcuFrameKardan;
   kardanFrame.mPos.mValues[0] := Tool.X_mm;
   kardanFrame.mPos.mValues[1] := Tool.Y_mm;
   kardanFrame.mPos.mValues[2] := Tool.Z_mm;
   kardanFrame.mOri.mValues[0] := Tool.A_deg;
   kardanFrame.mOri.mValues[1] := Tool.B_deg;
   kardanFrame.mOri.mValues[2] := Tool.C_deg;
   
   IF RcData.CheckKin(elem, "SETTOOL") THEN
      IF elem.kin.homing.SimulateMacro("SETTOOL") THEN
         elem.kin.homing.lastToolFrame := kardanFrame;
         elem.kin.homing.lastToolName  := Tool.GetName();
         RETURN;
      END_IF;
       IF gMcuFrameTyp = eMcuFrameEuler THEN
          RcuSetMessageOnce(EcoTalk_WarWrongTypeOfFrame, elem.kin.kinListInx, 1, 0, "Ecotalk.SETTOOL");
          frame.mPos := kardanFrame.mPos;
          McuKardanToEuler(frame.mOri, kardanFrame.mOri);
          frame.mFrameTyp := eMcuFrameEuler;
          s := Tool.GetName();
          elem.kin.Tool(s, frame);
       ELSE
          frame.mPos := kardanFrame.mPos;
          frame.mOri := kardanFrame.mOri;
          frame.mFrameTyp := eMcuFrameKardan;
          s := Tool.GetName();
          elem.kin.Tool(s, frame);
       END_IF;
   END_IF;
END_ROUTINE

ROUTINE SETEXTTOOL(Tool : TOOL) GLOBAL USER { macro="GEOMETRIC" }
   VAR
      kardanFrame : TMcuFrame;
      frame : TMcuFrame;
      elem : TRcuKinListElem; // element with the kinematicreference
      s : STRING;
   END_VAR
   
   kardanFrame.mFrameTyp := eMcuFrameKardan;
   kardanFrame.mPos.mValues[0] := Tool.X_mm;
   kardanFrame.mPos.mValues[1] := Tool.Y_mm;
   kardanFrame.mPos.mValues[2] := Tool.Z_mm;
   kardanFrame.mOri.mValues[0] := Tool.A_deg;
   kardanFrame.mOri.mValues[1] := Tool.B_deg;
   kardanFrame.mOri.mValues[2] := Tool.C_deg;
   
   IF RcData.CheckKin(elem, "SETEXTTOOL") THEN
       IF gMcuFrameTyp = eMcuFrameEuler THEN
          RcuSetMessageOnce(EcoTalk_WarWrongTypeOfFrame, elem.kin.kinListInx, 1, 0, "Ecotalk.SETTOOL");
          frame.mPos := kardanFrame.mPos;
          McuKardanToEuler(frame.mOri, kardanFrame.mOri);
          frame.mFrameTyp := eMcuFrameEuler;
          s := Tool.GetName();
          elem.kin.ExtTool(s, frame);
       ELSE
          frame.mPos := kardanFrame.mPos;
          frame.mOri := kardanFrame.mOri;
          frame.mFrameTyp := eMcuFrameKardan;
          s := Tool.GetName();
          elem.kin.ExtTool(s, frame);
       END_IF;
   END_IF;
END_ROUTINE

(*
// not currently used
ROUTINE SETFIXTOOL(ToolNr : DINT) GLOBAL USER { macro="GEOMETRIC" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
      s : STRING;
   END_VAR
   
   IF RcData.CheckKin(elem, "SETFIXTOOL") THEN
      elem.kin.FixTool(ToolNr);
   END_IF;
END_ROUTINE
*)

// --------------------- E C O T A L K -----------------------------------------
// set the interpolation mode for the orientation
ROUTINE SETINTMODE(mode : INTERPOLATIONTYPE) GLOBAL USER { macro="GEOMETRIC" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "SETINTMODE") THEN
      CASE mode OF
         WRISTJOINT    : elem.kin.progPath.Ori(eMcuWristJoints);
         ZROTATION     : elem.kin.progPath.Ori(eMcuZRotation);
         ZROTATIONCIRC : elem.kin.progPath.Ori(eMcuZRotationCirc);
      ELSE
         RcuSetMessageOnce(EcoTalk_WarIntTypeUnknown, elem.kin.kinListInx, 1, 0, "Ecotalk.SETINTMODE");
      END_CASE;
   END_IF;
END_ROUTINE

(******************************************************************************************************************
******************   Group  PROCESS in Teachview - menu  **********************************************************
******************************************************************************************************************)

// --------------------- E C O T A L K -----------------------------------------
// 15-08-2003 Bauder
// Set a gun-command for the next segment
ROUTINE GUN(Number : GUNNO; Command : GUNONOFF; point : POINT; 
            Trigger : TRIGGERFRAME) GLOBAL USER { macro="PROCESS" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "GUN") THEN
      IF elem.kin.homing.SimulateMacro("GUN") OR elem.kin.homing.bHomingRun THEN
         RETURN;
      END_IF;
      
      IF Command = GunOn THEN
         elem.kin.RcuInterfaceToProcess.startTriggerName := Trigger.GetName();
      ELSIF Command = GunOff THEN
         elem.kin.RcuInterfaceToProcess.startTriggerName := "";
      END_IF;      
      Trigger.TriggerGun(elem, Number, Command, point);
   END_IF;  

END_ROUTINE


ROUTINE GUN_DIRECT(Number : GUNNO; Command : GUNONOFF) GLOBAL USER { macro="PROCESS" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "GUN_DIRECT") THEN
      IF elem.kin.homing.SimulateMacro("GUN_DIRECT") OR elem.kin.homing.bHomingRun THEN
         RETURN;
      END_IF;
      
      IF elem.kin.paintChecker.type = eRcuPaintCheckerOff THEN
      START elem.kin.RcuInterfaceToProcess.GunDirect(Number, Command);
      ELSE
         START elem.kin.paintChecker.GunDirect(Number, Command);
      END_IF;
   END_IF;  

END_ROUTINE


// --------------------- E C O T A L K -----------------------------------------
// 21-08-2003 Bauder
// Set a brush-command for the next segment
//ROUTINE SETBRUSH(gunNumber : DINT; brushNumber : DINT; trigger : TRcuTriggerBrush) GLOBAL USER
ROUTINE SETBRUSH(Number : GUNNO; Brush : DINT; point : POINT; 
            Trigger : TRIGGERFRAME) GLOBAL USER { macro="PROCESS" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR

   IF RcData.CheckKin(elem, "SETBRUSH") THEN
      IF elem.kin.homing.SimulateMacro("SETBRUSH") OR elem.kin.homing.bHomingRun THEN
         RETURN;
      END_IF;
      
      Trigger.TriggerSetBrush(elem, Number, Brush, point);
   END_IF;
END_ROUTINE


ROUTINE SETBRUSH_DIRECT(Number : GUNNO; Brush : DINT) GLOBAL USER { macro="PROCESS" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR

   IF RcData.CheckKin(elem, "SETBRUSH_DIRECT") THEN
      IF elem.kin.homing.SimulateMacro("SETBRUSH_DIRECT") OR elem.kin.homing.bHomingRun THEN
         RETURN;
      END_IF;
      
      START elem.kin.RcuInterfaceToProcess.SetBrushDirect(Number, Brush);
   END_IF;
END_ROUTINE


// 05-10-05 Bitzer
// tell the IEC-Process a command by EcoTalk
ROUTINE SETPROCESSCOMMAND(Command : COMMAND; point : POINT; 
            Trigger : TRIGGERFRAME) GLOBAL USER { macro="PROCESS" }
  VAR
    elem : TRcuKinListElem; // element with the kinematicreference
  END_VAR
   
  IF RcData.CheckKin(elem, "SETPROCESSCOMMAND") THEN
      IF elem.kin.homing.SimulateMacro("SETPROCESSCOMMAND") THEN
         RETURN;
      END_IF;
      
     Trigger.TriggerProcessCommand(elem, Command, point);
  END_IF;
  
END_ROUTINE   


// 03-11-2003 Bauder
// wait until the process signals that movement can start
ROUTINE WAIT_PROCESS_READY() GLOBAL USER { macro="PROCESS" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
      iLine : INT;
      info    : TUserProgStackInfo;
   END_VAR

   IF RcData.CheckKin(elem, "WAIT_PROCESS_READY") THEN
      IF gbIsTrackingStation THEN
         elem.kin.DebugPrint(eTraceProcess, "EcoTalkMacro WAIT_PROCESS_READY ignored, because gbIsTrackingStation=" + STR(gbIsTrackingStation));
         RETURN;
      END_IF;   
      IF elem.kin.homing.SimulateMacro("WAIT_PROCESS_READY") THEN
         RETURN;
      END_IF;
      elem.kin.progPath.wait_process_ready(elem.kin.kinListInx);
   END_IF;
END_ROUTINE



ROUTINE SET_SEAMTOLERANCE(value : REAL) GLOBAL USER { macro="PROCESS" }
   START SetSeamToleranceMR(value);
END_ROUTINE


ROUTINE SetSeamToleranceMR(value : REAL) PRIVATE
   VAR
      locStartTriggerName : STRING;
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "SetSeamToleranceMR") THEN
      IF elem.kin.homing.SimulateMacro("SETSEAMTOLERANCE") THEN
         RETURN;
      END_IF;
      
      locStartTriggerName := elem.kin.RcuInterfaceToProcess.startTriggerName;
      IF locStartTriggerName <> "" THEN
         WAIT (locStartTriggerName = elem.kin.RcuInterfaceToProcess.svTriggerInfo.zStartTrigger);
         elem.kin.RcuInterfaceToProcess.seamTolerance := value;
      END_IF;
   END_IF;
END_ROUTINE

(******************************************************************************************************************
******************   Group  Tracking in Teachview - menu  *********************************************************
******************************************************************************************************************)

// macro for tracking
ROUTINE TRACKING(Cmd : TRcuTrackingCmd) GLOBAL USER { macro="Tracking" | enable="_system.gbIsTrackingStation"}
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
      iLine : INT;
      info    : TUserProgStackInfo;
   END_VAR

   IF RcData.CheckKin(elem, "TRACKING") THEN
      IF NOT (elem.kin.lineTracking OR elem.kin.railTracking) THEN
         RcuResetMessage(EcoTalk_WarMacroIgnored, elem.kin.kinListInx, 1, 0, "EcoTalk.TRACKING", "TRACKING");
         RETURN;
      END_IF;
      IF giRcuTrackingStyle <> 0 THEN
         RcuResetMessage(EcoTalk_WarOldMacroIgnored, elem.kin.kinListInx, 1, 0, "EcoTalk.TRACKING", "TRACKING");
         RETURN;
      END_IF;
      
      IF elem.kin.homing.SimulateMacro("TRACKING") THEN
         RETURN;
      END_IF;
      elem.kin.tracking.Tracking(Cmd);
   END_IF;
   RETURN;
END_ROUTINE


// macro for tracking
ROUTINE SETTRACKINGMODE(mode : TRcuTrackingMode) GLOBAL USER { macro="Tracking" | enable="_system.gbIsTrackingStation"}
   VAR
      iLine   : DINT;
      elem    : TRcuKinListElem; // element with the kinematicreference
      info    : TUserProgStackInfo;
   END_VAR

   IF RcData.CheckKin(elem, "SETTRACKINGMODE") THEN
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
          iLine := info.lineNrs[info.depth-1]; 
         ELSE
          iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      IF NOT (elem.kin.lineTracking OR elem.kin.railTracking) THEN
         RcuResetMessage(EcoTalk_WarMacroIgnored, elem.kin.kinListInx, 7, 0, "EcoTalk.SETTRACKINGMODE", "SETTRACKINGMODE");
         RETURN;
      END_IF;
      IF NOT (elem.kin.railTracking) THEN // no railtracking configured
         STOPPOINT();
         RcuResetMessage(EcoTalk_ErrSetTrackingMode, elem.kin.kinListInx, 1, 0, "EcoTalk.SETTRACKINGMODE", STR(iLine), "SETTRACKINGMODE");
         elem.kin.ErrorReaction(TRUE);
         RETURN;
      END_IF;
      
      elem.kin.tracking.SetTrackingMode(mode);
   END_IF;
   RETURN;
END_ROUTINE


// macro for tracking
ROUTINE WAIT_CONVEYOR(Conveyor: REAL) GLOBAL USER { macro="Tracking" | enable="_system.gbIsTrackingStation"}  
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR

   IF RcData.CheckKin(elem, "WAIT_CONVEYOR") THEN
      IF NOT (elem.kin.lineTracking OR elem.kin.railTracking) THEN
         RcuResetMessage(EcoTalk_WarMacroIgnored, elem.kin.kinListInx, 2, 0, "EcoTalk.WAIT_CONVEYOR", "WAIT_CONVEYOR");
         RETURN;
      END_IF;
      IF giRcuTrackingStyle <> 0 THEN
         RcuResetMessage(EcoTalk_WarOldMacroIgnored, elem.kin.kinListInx, 2, 0, "EcoTalk.WAIT_CONVEYOR", "WAIT_CONVEYOR");
         RETURN;
      ELSE
         IF elem.kin.homing.SimulateMacro("WAIT_CONVEYOR") THEN
            RETURN;
         END_IF;
         elem.kin.tracking.WaitConveyor(Conveyor);
      END_IF;
   END_IF;
END_ROUTINE


// macro for tracking
ROUTINE CHECK_CONVEYOR(Conveyor: REAL): BOOL GLOBAL USER { macro="Tracking" | enable="_system.gbIsTrackingStation"}  
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR

   IF RcData.CheckKin(elem, "CHECK_CONVEYOR") THEN
      IF NOT (elem.kin.lineTracking OR elem.kin.railTracking) THEN
         RcuResetMessage(EcoTalk_WarMacroIgnored, elem.kin.kinListInx, 3, 0, "EcoTalk.WAIT_CONVEYOR", "WAIT_CONVEYOR");
         RETURN FALSE;
      END_IF;
      IF giRcuTrackingStyle <> 0 THEN
         RcuResetMessage(EcoTalk_WarOldMacroIgnored, elem.kin.kinListInx, 3, 0, "EcoTalk.WAIT_CONVEYOR", "WAIT_CONVEYOR");
         RETURN FALSE;
      ELSE
         RETURN elem.kin.tracking.CheckConveyor(Conveyor);
      END_IF;
   END_IF;
   RETURN FALSE;
END_ROUTINE


// waiting until paint-position reached
// macro for tracking
ROUTINE WAIT_PAINTPOSITION(Paintposition: REAL) GLOBAL USER { macro="Tracking" | enable="_system.gbIsTrackingStation"}
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR

   IF RcData.CheckKin(elem, "WAIT_PAINTPOSITION") THEN
      IF NOT (elem.kin.lineTracking OR elem.kin.railTracking) THEN
         RcuResetMessage(EcoTalk_WarMacroIgnored, elem.kin.kinListInx, 4, 0, "EcoTalk.WAIT_PAINTPOSITION", "WAIT_PAINTPOSITION");
         RETURN;
      END_IF;
      IF giRcuTrackingStyle <> 0 THEN
         RcuResetMessage(EcoTalk_WarOldMacroIgnored, elem.kin.kinListInx, 4, 0, "EcoTalk.WAIT_PAINTPOSITION", "WAIT_PAINTPOSITION");
         RETURN;
      END_IF; 
      IF elem.kin.homing.SimulateMacro("WAIT_PAINTPOSITION") THEN
         RETURN;
      END_IF;
      elem.kin.tracking.WaitPaintposition(Paintposition);
   END_IF;
END_ROUTINE

(*
// currently not used
// waiting until paint-position reached
// macro for tracking
ROUTINE WAIT_PURGEONPAINTPOS(Paintposition: REAL): BOOL GLOBAL USER { macro="Tracking" | enable="_system.gbIsTrackingStation"}
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR

   IF RcData.CheckKin(elem, "WAIT_PURGEONPAINTPOS") THEN
      IF NOT (elem.kin.lineTracking OR elem.kin.railTracking) THEN
         RcuResetMessage(EcoTalk_WarMacroIgnored, elem.kin.kinListInx, 5, 0, "EcoTalk.WAIT_PURGEONPAINTPOS", "WAIT_PURGEONPAINTPOS");
         RETURN FALSE;
      END_IF;
      IF giRcuTrackingStyle <> 0 THEN
         RcuResetMessage(EcoTalk_WarOldMacroIgnored, elem.kin.kinListInx, 5, 0, "EcoTalk.WAIT_PURGEONPAINTPOS", "WAIT_PURGEONPAINTPOS");
         RETURN FALSE;
      END_IF;
      RETURN elem.kin.tracking.WaitPurgeOnPaintpos(Paintposition);
   END_IF;
   RETURN FALSE;
END_ROUTINE
*)

// macro for tracking
ROUTINE GET_PAINTPOSITION(GreaterSmaller: TRcuGreaterSmaller; Paintposition: REAL 
                          ): BOOL GLOBAL USER { macro="Tracking" | enable="_system.gbIsTrackingStation"}
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR

   IF RcData.CheckKin(elem, "GET_PAINTPOSITION") THEN
      IF NOT (elem.kin.lineTracking OR elem.kin.railTracking) THEN
         RcuResetMessage(EcoTalk_WarMacroIgnored, elem.kin.kinListInx, 6, 0, "EcoTalk.GET_PAINTPOSITION", "GET_PAINTPOSITION");
         RETURN TRUE;
      END_IF;
      IF giRcuTrackingStyle <> 0 THEN
         RcuResetMessage(EcoTalk_WarOldMacroIgnored, elem.kin.kinListInx, 6, 0, "EcoTalk.GET_PAINTPOSITION", "GET_PAINTPOSITION");
         RETURN TRUE;
      END_IF;
 
      RETURN elem.kin.tracking.GetPaintposition(GreaterSmaller, Paintposition);
   END_IF;
   RETURN TRUE;
END_ROUTINE


(******************************************************************************************************************
******************   Group  Handler in Teachview - menu  *********************************************************
******************************************************************************************************************)

// --------------------- E C O T A L K -----------------------------------------
ROUTINE RECEIVE_ORDER(SourcePartTV : PART; SourcePosTV : POSITION; 
                      DestPartTV : PART; DestPosTV : POSITION) GLOBAL USER 
                      { macro="HANDLER" | enable="_system.gRcuFocusedRobot.handler.partPosPerHandler" }
   VAR
      handlerIniPart : THandlerIniPart;                 
      handlerEndPart : THandlerEndPart;
      elem           : TRcuKinListElem;
      startInPartPos : BOOL;
   END_VAR
   
   IF RcData.CheckKin(elem, "RECEIVE_ORDER") THEN
      IF elem.kin.handler.isHandler AND elem.kin.handler.partPosPerHandler THEN
         
         IF elem.kin.handler.hasAdditionalPart THEN // check if functionality is configured
            IF (SourcePartTV = elem.kin.handler.replacingPartNr) THEN
               STOPPOINT();
               RcuSetMessageOnce(EcoTalk_ErrPartPosNDef, elem.kin.kinListInx, 1, 0, "Ecotalk.RECEIVE_ORDER", STR(SourcePartTV));
               elem.kin.ErrorReaction(TRUE);
            END_IF;
            IF (SourcePartTV = elem.kin.handler.additionalPartNr) THEN
               elem.kin.DebugPrint(eTraceRcuHandler, "RECEIVE_ORDER, source part nr before chg : " + STR(SourcePartTV));
               SourcePartTV := PART(elem.kin.handler.replacingPartNr);
               elem.kin.DebugPrint(eTraceRcuHandler, "RECEIVE_ORDER, source part nr after chg : " + STR(SourcePartTV));
            END_IF;
            IF (DestPartTV = elem.kin.handler.replacingPartNr) THEN
               STOPPOINT();
               RcuSetMessageOnce(EcoTalk_ErrPartPosNDef, elem.kin.kinListInx, 2, 0, "Ecotalk.RECEIVE_ORDER", STR(DestPartTV));
               elem.kin.ErrorReaction(TRUE);
            END_IF;
            IF (DestPartTV = elem.kin.handler.additionalPartNr) THEN
               elem.kin.DebugPrint(eTraceRcuHandler, "RECEIVE_ORDER, dest part nr before chg : " + STR(DestPartTV));
               DestPartTV := PART(elem.kin.handler.replacingPartNr);
               elem.kin.DebugPrint(eTraceRcuHandler, "RECEIVE_ORDER, dest part nr after chg : " + STR(DestPartTV));
            END_IF;
         END_IF;
         
         //Pos5 is defined as home  
         IF (SourcePosTV =  5) THEN
            handlerIniPart := StartHomePos;
         ELSE
            CASE SourcePartTV OF
               1: handlerIniPart := StartPart1;
                  IF (SourcePosTV >= 1) AND (SourcePosTV <= 4) THEN
                     elem.kin.handler.partsIni[1] := SourcePosTV;
                     startInPartPos := TRUE;
                  END_IF;
               2: handlerIniPart := StartPart2;
                  IF (SourcePosTV >= 1) AND (SourcePosTV <= 4) THEN
                     elem.kin.handler.partsIni[2] := SourcePosTV;
                     startInPartPos := TRUE;
                  END_IF;
               3: handlerIniPart := StartPart3;
                  IF (SourcePosTV >= 1) AND (SourcePosTV <= 4) THEN
                     elem.kin.handler.partsIni[3] := SourcePosTV;
                     startInPartPos := TRUE;
                  END_IF;
               4: handlerIniPart := StartPart4;
                  IF (SourcePosTV >= 1) AND (SourcePosTV <= 4) THEN
                     elem.kin.handler.partsIni[4] := SourcePosTV;
                     startInPartPos := TRUE;
                  END_IF;
            ELSE
              STOPPOINT();
              RcuSetMessageOnce(EcoTalk_ErrPartPosNDef, elem.kin.kinListInx, 3, 0, "Ecotalk.RECEIVE_ORDER", STR(SourcePartTV));
              elem.kin.ErrorReaction(TRUE);
              RETURN;
            END_CASE;
         END_IF;
         
         //Pos5 is defined as home
         IF (DestPosTV =  5) THEN
            handlerEndPart := StopHomePos;
         ELSE
            CASE DestPartTV OF
             1: handlerEndPart := StopPart1;
             2: handlerEndPart := StopPart2;
             3: handlerEndPart := StopPart3;
             4: handlerEndPart := StopPart4;
            ELSE
              STOPPOINT();
              RcuSetMessageOnce(EcoTalk_ErrPartPosNDef, elem.kin.kinListInx, 4, 0, "Ecotalk.RECEIVE_ORDER", STR(DestPartTV));
              elem.kin.ErrorReaction(TRUE);
              RETURN;
            END_CASE;
         END_IF;
         
         STOPPOINT();
         elem.kin.handler.ReceiveOrder(handlerIniPart, handlerEndPart, startInPartPos);
         
      ELSE   
         STOPPOINT();
         RcuSetMessageOnce(EcoTalk_ErrCmdActivated, elem.kin.kinListInx, 1, 0, "Ecotalk.RECEIVE_ORDER", "RECEIVE_ORDER");
         elem.kin.ErrorReaction(TRUE);     
      END_IF;
   END_IF;
   
END_ROUTINE

// --------------------- E C O T A L K -----------------------------------------
ROUTINE RECEIVE_PARTORDER(rob1 : ROBOT; rob2 : ROBOT; part : PART; pos : POSITION) : BOOL GLOBAL USER 
                      { macro="HANDLER" | enable="_system.gRcuFocusedRobot.handler.partPosPerBody" }
 VAR
  elem : TRcuKinListElem;
 END_VAR
   
  IF RcData.CheckKin(elem, "RECEIVE_PARTORDER") THEN
     STOPPOINT();
     IF elem.kin.handler.isHandler AND elem.kin.handler.partPosPerBody THEN
        IF (rob1 < 0) OR (rob1 > cgiMaxNumOfOrderer) THEN
            RcuSetMessageOnce(EcoTalk_ErrRobPartPosNDef, elem.kin.kinListInx, 1, 0, "Ecotalk.RECEIVE_PARTORDER", "rob1="+STR(rob1));
            elem.kin.ErrorReaction(TRUE);
            RETURN FALSE;
        END_IF;
        IF (rob2 < 0) OR (rob2 > cgiMaxNumOfOrderer) THEN
            RcuSetMessageOnce(EcoTalk_ErrRobPartPosNDef, elem.kin.kinListInx, 2, 0, "Ecotalk.RECEIVE_PARTORDER", "rob2="+STR(rob2));
            elem.kin.ErrorReaction(TRUE);
            RETURN FALSE;
        END_IF;
        IF (rob1=0) AND (rob2=0) THEN
            RcuSetMessageOnce(EcoTalk_ErrRobPartPosNDef, elem.kin.kinListInx, 3, 0, "Ecotalk.RECEIVE_PARTORDER", "rob1="+STR(rob1)+" rob2="+STR(rob2));
            elem.kin.ErrorReaction(TRUE);
            RETURN FALSE;
        END_IF;        
        IF (part < 1) OR (part > cgiMaxNumOfParts) THEN
            RcuSetMessageOnce(EcoTalk_ErrRobPartPosNDef, elem.kin.kinListInx, 4, 0, "Ecotalk.RECEIVE_PARTORDER", "part="+STR(part));
            elem.kin.ErrorReaction(TRUE);
            RETURN FALSE;
         END_IF;
         IF (pos < 1) OR (pos > cgiMaxNumOfPositions) THEN
            RcuSetMessageOnce(EcoTalk_ErrRobPartPosNDef, elem.kin.kinListInx, 5, 0, "Ecotalk.RECEIVE_PARTORDER", "pos="+STR(pos));
            elem.kin.ErrorReaction(TRUE);
            RETURN FALSE;
         END_IF;
        
         RETURN elem.kin.handler.ReceivePartOrder(rob1, rob2, part, pos);
     
     ELSE   
        RcuSetMessageOnce(EcoTalk_ErrCmdActivated, elem.kin.kinListInx, 9, 0, "Ecotalk.RECEIVE_ORDER", "RECEIVE_PARTORDER");
        elem.kin.ErrorReaction(TRUE);   
        RETURN FALSE;
     END_IF;
  END_IF;
  RETURN FALSE;
  
END_ROUTINE

// --------------------- E C O T A L K -----------------------------------------
ROUTINE SET_ORDER(handler : HANDLER; part : PART; pos : POSITION) GLOBAL USER 
                 { macro="HANDLER" | enable="_system.gRcuFocusedRobot.handler.isOrderer" }
   VAR
     elem       : TRcuKinListElem;
   END_VAR
   
   IF RcData.CheckKin(elem, "SET_ORDER") THEN
      //partPosPerHandler
      IF elem.kin.handler.isOrderer AND elem.kin.handler.partPosPerHandler THEN
         
         IF elem.kin.handler.hasAdditionalPart THEN // check if functionality is configured
            IF (part = elem.kin.handler.replacingPartNr) AND elem.kin.handler.addPartHandlerNr[handler] THEN
               STOPPOINT();
               RcuSetMessageOnce(EcoTalk_ErrHanPartPosNDef, elem.kin.kinListInx, 1, 0, "Ecotalk.SET_ORDER", STR(part));
               elem.kin.ErrorReaction(TRUE);
            END_IF;
            IF (part = elem.kin.handler.additionalPartNr) AND NOT elem.kin.handler.addPartHandlerNr[handler] THEN
               STOPPOINT();
               RcuSetMessageOnce(EcoTalk_ErrHanPartPosNDef, elem.kin.kinListInx, 2, 0, "Ecotalk.SET_ORDER", STR(part));
               elem.kin.ErrorReaction(TRUE);
            END_IF;
            IF (part = elem.kin.handler.additionalPartNr) AND elem.kin.handler.addPartHandlerNr[handler] THEN
               elem.kin.DebugPrint(eTraceRcuHandler, "SET_ORDER, part nr before chg : " + STR(part));
               part := PART(elem.kin.handler.replacingPartNr);
               elem.kin.DebugPrint(eTraceRcuHandler, "SET_ORDER, part nr after chg : " + STR(part));
            END_IF;
         END_IF;
         
         IF (handler < 0) OR (handler > 3) THEN
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrHanPartPosNDef, elem.kin.kinListInx, 3, 0, "Ecotalk.SET_ORDER", STR(handler));
            elem.kin.ErrorReaction(TRUE);
            RETURN;
         END_IF;
         IF (part < 0) OR (part > 4) THEN
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrHanPartPosNDef, elem.kin.kinListInx, 4, 0, "Ecotalk.SET_ORDER", STR(part));
            elem.kin.ErrorReaction(TRUE);
            RETURN;
         END_IF;
         IF (pos < -2) OR (pos > 4) THEN
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrHanPartPosNDef, elem.kin.kinListInx, 5, 0, "Ecotalk.SET_ORDER", STR(pos));
            elem.kin.ErrorReaction(TRUE);
            RETURN;
         END_IF;
         
         IF (part = 0) AND (pos >= 0) THEN
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrPartPosNDef, elem.kin.kinListInx, 5, 0, "Ecotalk.SET_ORDER", "Teil 0, Pos " + STR(pos));
            elem.kin.ErrorReaction(TRUE);
            RETURN;
         END_IF;
         
         elem.kin.bSetOrderFlag := TRUE;
         START elem.kin.handler.SetOrderToPLC(handler, part, pos, TRUE);
         
      //partPosPerBody   
      ELSIF elem.kin.handler.isOrderer AND elem.kin.handler.partPosPerBody THEN   
         
         IF (handler < 1) OR (handler > cgiMaxNumOfHandlers) THEN
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrHanPartPosNDef, elem.kin.kinListInx, 6, 0, "Ecotalk.SET_ORDER", "handler="+STR(handler));
            elem.kin.ErrorReaction(TRUE);
            RETURN;
         END_IF;
         IF (part < 1) OR (part > cgiMaxNumOfParts) THEN
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrHanPartPosNDef, elem.kin.kinListInx, 7, 0, "Ecotalk.SET_ORDER", "part="+STR(part));
            elem.kin.ErrorReaction(TRUE);
            RETURN;
         END_IF;
         IF (pos < 0) OR (pos > cgiMaxNumOfPositions) THEN
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrHanPartPosNDef, elem.kin.kinListInx, 8, 0, "Ecotalk.SET_ORDER", "pos="+STR(pos));
            elem.kin.ErrorReaction(TRUE);
            RETURN;
         END_IF;
         
         elem.kin.bSetOrderFlag := TRUE;
         START elem.kin.handler.SetOrderToPLC(handler, part, pos, TRUE);   
          
      ELSE   
         STOPPOINT();
         RcuSetMessageOnce(EcoTalk_ErrCmdActivated, elem.kin.kinListInx, 2, 0, "Ecotalk.SET_ORDER", "SET_ORDER");
         elem.kin.ErrorReaction(TRUE);
      END_IF;
   END_IF;
   
END_ROUTINE

// --------------------- E C O T A L K -----------------------------------------
ROUTINE SET_POSCODE(part : PART; pos : POSITION) GLOBAL USER { macro="HANDLER" | enable="_system.gRcuFocusedRobot.handler.partPosPerBody" }
   VAR
     elem       : TRcuKinListElem;
   END_VAR
   
   IF RcData.CheckKin(elem, "SET_ORDER") THEN
      //Error handling
      IF elem.kin.handler.isHandler AND elem.kin.handler.partPosPerBody THEN
         IF (part < 1) OR (part > cgiMaxNumOfParts) THEN
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrHanPartPosNDef, elem.kin.kinListInx, 1, 0, "Ecotalk.SET_POSCODE", "part="+STR(part));
            elem.kin.ErrorReaction(TRUE);
            RETURN;
         END_IF;
         IF (pos < 0) OR (pos > cgiMaxNumOfPositions) THEN
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrHanPartPosNDef, elem.kin.kinListInx, 2, 0, "Ecotalk.SET_POSCODE", "pos="+STR(pos));
            elem.kin.ErrorReaction(TRUE);
            RETURN;
         END_IF;
         //start routine which is waiting for mainrun and sets the corresponding output there
         START elem.kin.handler.SetPosCodeToPLC(part, pos);
      ELSE
         STOPPOINT();
         RcuSetMessageOnce(EcoTalk_ErrCmdActivated, elem.kin.kinListInx, 8, 0, "Ecotalk.SET_POSCODE", "SET_POSCODE");
         elem.kin.ErrorReaction(TRUE);
         RETURN;
      END_IF;  
   END_IF;
     
END_ROUTINE

// --------------------- E C O T A L K -----------------------------------------
ROUTINE RECEIVE_HANDLERPOS(handler : HANDLER; part : PART; pos : POSITION) : BOOL GLOBAL USER 
                          { macro="HANDLER" | enable="_system.gRcuFocusedRobot.handler.partPosPerHandler" }
    
   VAR
     elem       : TRcuKinListElem;
     sLogText   : STRING;
   END_VAR
   
   IF RcData.CheckKin(elem, "RECEIVE_HANDLERPOS") THEN
      IF elem.kin.handler.isOrderer AND elem.kin.handler.partPosPerHandler THEN
         IF elem.kin.handler.hasAdditionalPart THEN // check if functionality is configured
            IF (part = elem.kin.handler.replacingPartNr) AND elem.kin.handler.addPartHandlerNr[handler] THEN
               STOPPOINT();
               RcuSetMessageOnce(EcoTalk_ErrHanPartPosNDef, elem.kin.kinListInx, 6, 0, "Ecotalk.RECEIVE_HANDLERPOS", STR(part));
               elem.kin.ErrorReaction(TRUE);
            END_IF;
            IF (part = elem.kin.handler.additionalPartNr) AND NOT elem.kin.handler.addPartHandlerNr[handler] THEN
               STOPPOINT();
               RcuSetMessageOnce(EcoTalk_ErrHanPartPosNDef, elem.kin.kinListInx, 7, 0, "Ecotalk.RECEIVE_HANDLERPOS", STR(part));
               elem.kin.ErrorReaction(TRUE);
            END_IF;
            IF (part = elem.kin.handler.additionalPartNr) AND elem.kin.handler.addPartHandlerNr[handler] THEN
               elem.kin.DebugPrint(eTraceRcuHandler, "RECEIVE_HANDLERPOS, part nr before chg : " + STR(part));
               part := PART(elem.kin.handler.replacingPartNr);
               elem.kin.DebugPrint(eTraceRcuHandler, "RECEIVE_HANDLERPOS, part nr after chg : " + STR(part));
            END_IF;
         END_IF;
         //check user parameters
         IF (handler < 0) OR (handler > 3) THEN
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrHanPartPosNDef, elem.kin.kinListInx, 8, 0, "Ecotalk.RECEIVE_HANDLERPOS", STR(handler));
            elem.kin.ErrorReaction(TRUE);
            RETURN FALSE;
         END_IF;
         IF (part < 1) OR (part > 4) THEN
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrHanPartPosNDef, elem.kin.kinListInx, 9, 0, "Ecotalk.RECEIVE_HANDLERPOS", STR(part));
            elem.kin.ErrorReaction(TRUE);
            RETURN FALSE;
         END_IF;
         IF (pos < 0) OR (pos > 4) THEN
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrHanPartPosNDef, elem.kin.kinListInx, 10, 0, "Ecotalk.RECEIVE_HANDLERPOS", STR(pos));
            elem.kin.ErrorReaction(TRUE);
            RETURN FALSE;
         END_IF;
         //If robot is orderer and handler don't ignore this macro, because in this case the robot is not disabled by PLC
         IF (NOT elem.kin.handler.isHandler) AND elem.kin.allDrivesSimulated THEN
            RETURN TRUE; //GhostNoMotion the handlerstates have to be simulated, because it's disabled
         END_IF;     
         IF NOT elem.kin.handler.myRobot.fieldbusIn.yHwInRobotFromHandler[handler].bOnline.svBool THEN
            sLogText := "Handler " + STR(handler) + " is not selected - Prerun";
            elem.kin.logger.SetLoggerStep(elem.kin.handler.iLoggerNumber, sLogText);
            IF elem.kin.bHasProcess THEN
               elem.kin.RcuInterfaceToProcess.svMotionAbortPushOut := TRUE;
            END_IF;
            RETURN FALSE;
         END_IF;
         STOPPOINT();
         WAIT elem.kin.handler.myRobot.fieldbusIn.yHwInRobotFromHandler[handler].part[part].pos[pos].svBool OR
              (NOT elem.kin.handler.myRobot.fieldbusIn.yHwInRobotFromHandler[handler].bOnline.svBool);
              
         IF NOT elem.kin.handler.myRobot.fieldbusIn.yHwInRobotFromHandler[handler].bOnline.svBool THEN
            sLogText := "Handler " + STR(handler) + " is not selected - Mainrun";
            elem.kin.logger.SetLoggerStep(elem.kin.handler.iLoggerNumber, sLogText);
            IF elem.kin.bHasProcess THEN
               elem.kin.RcuInterfaceToProcess.svMotionAbortPushOut := TRUE;
            END_IF;
            RETURN FALSE;
         ELSE
            sLogText := "Received Pos for " + STR(handler) + " Part " + STR(part) + " Pos " + STR(pos);
            elem.kin.logger.SetLoggerStep(elem.kin.handler.iLoggerNumber, sLogText);
            RETURN TRUE;
         END_IF;      
      ELSE
         STOPPOINT();
         RcuSetMessageOnce(EcoTalk_ErrCmdActivated, elem.kin.kinListInx, 3, 0, "Ecotalk.RECEIVE_HANDLERPOS", "RECEIVE_HANDLERPOS");
         elem.kin.ErrorReaction(TRUE);
         RETURN FALSE;
      END_IF; // IF elem.kin.handler.isOrderer THEN
   ELSE   
      RETURN FALSE;
   END_IF; // IF RcData.CheckKin(elem, "RECEIVE_HANDLERPOS") THEN
    
END_ROUTINE

// --------------------- E C O T A L K -----------------------------------------
ROUTINE RECEIVE_PARTPOS(handler : HANDLER; part : PART; pos : POSITION) : BOOL GLOBAL USER 
                          { macro="HANDLER" | enable="_system.gRcuFocusedRobot.handler.partPosPerBody" }
    
   VAR
     elem       : TRcuKinListElem;
     sLogText   : STRING;
   END_VAR
   
   IF RcData.CheckKin(elem, "RECEIVE_PARTPOS") THEN
      IF elem.kin.handler.isOrderer AND elem.kin.handler.partPosPerBody THEN
         //check user parameters
         IF (handler < 1) OR (handler > cgiMaxNumOfHandlers) THEN
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrHanPartPosNDef, elem.kin.kinListInx, 11, 0, "Ecotalk.RECEIVE_HANDLERPOS", "handler="+STR(handler));
            elem.kin.ErrorReaction(TRUE);
            RETURN FALSE;
         END_IF;
         IF (part < 1) OR (part > cgiMaxNumOfParts) THEN
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrHanPartPosNDef, elem.kin.kinListInx, 12, 0, "Ecotalk.RECEIVE_HANDLERPOS", "part="+STR(part));
            elem.kin.ErrorReaction(TRUE);
            RETURN FALSE;
         END_IF;
         IF (pos < 1) OR (pos > cgiMaxNumOfPositions) THEN
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrHanPartPosNDef, elem.kin.kinListInx, 13, 0, "Ecotalk.RECEIVE_HANDLERPOS", "pos="+STR(pos));
            elem.kin.ErrorReaction(TRUE);
            RETURN FALSE;
         END_IF;
         //If robot is orderer and handler don't ignore this macro, because in this case the robot is not disabled by PLC
         IF (NOT elem.kin.handler.isHandler) AND elem.kin.allDrivesSimulated THEN
            sLogText := "GhostNoMotion RECEIVE_PARTPOS ignored handler=" + STR(handler);
            elem.kin.logger.SetLoggerStep(elem.kin.handler.iLoggerNumber, sLogText);
            RETURN TRUE; //GhostNoMotion the handlerstates have to be simulated, because it's disabled
         END_IF;
         IF NOT elem.kin.handler.myRobot.fieldbusIn.tInHandling.yHandlerOnline[handler-1].svBool THEN
            sLogText := "RECEIVE_PARTPOS handler=" + STR(handler) + " is not selected - Prerun";
            elem.kin.logger.SetLoggerStep(elem.kin.handler.iLoggerNumber, sLogText);
            IF elem.kin.bHasProcess THEN
               elem.kin.RcuInterfaceToProcess.svMotionAbortPushOut := TRUE;
            END_IF;
            RETURN FALSE;
         END_IF;
         STOPPOINT();
         RETURN elem.kin.handler.ReceivePartPos(handler, part, pos);
      ELSE
         STOPPOINT();
         RcuSetMessageOnce(EcoTalk_ErrCmdActivated, elem.kin.kinListInx, 10, 0, "Ecotalk.RECEIVE_PARTPOS", "RECEIVE_PARTPOS");
         elem.kin.ErrorReaction(TRUE);
         RETURN FALSE;
      END_IF; // IF elem.kin.handler.isOrderer THEN
   ELSE   
      RETURN FALSE;
   END_IF; // IF RcData.CheckKin(elem, "RECEIVE_PARTPOS") THEN   
END_ROUTINE

// --------------------- E C O T A L K -----------------------------------------
ROUTINE SET_INIPOS(part : PART; pos : POSITION) GLOBAL USER 
                  { macro="HANDLER" | enable="_system.gRcuFocusedRobot.handler.partPosPerHandler" }
   VAR
     elem       : TRcuKinListElem;
   END_VAR
   
   IF RcData.CheckKin(elem, "SET_INIPOS") THEN
      IF elem.kin.handler.isHandler AND elem.kin.handler.partPosPerHandler THEN
         
         IF elem.kin.handler.hasAdditionalPart THEN // check if functionality is configured
            IF (part = elem.kin.handler.replacingPartNr) THEN
               STOPPOINT();
               RcuSetMessageOnce(EcoTalk_ErrPartPosNDef, elem.kin.kinListInx, 6, 0, "Ecotalk.SET_INIPOS", STR(part));
               elem.kin.ErrorReaction(TRUE);
            END_IF;
            IF (part = elem.kin.handler.additionalPartNr) THEN
               elem.kin.DebugPrint(eTraceRcuHandler, "SET_INIPOS, part nr before chg : " + STR(part));
               part := PART(elem.kin.handler.replacingPartNr);
               elem.kin.DebugPrint(eTraceRcuHandler, "SET_INIPOS, part nr after chg : " + STR(part));
            END_IF;
         END_IF;
         
         IF (part < 1) OR (part > 4) THEN
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrPartPosNDef, elem.kin.kinListInx, 7, 0, "Ecotalk.SET_INIPOS", STR(part));
            elem.kin.ErrorReaction(TRUE);
            RETURN;
         END_IF;
         IF (pos < 1) OR (pos > 4) THEN
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrPartPosNDef, elem.kin.kinListInx, 8, 0, "Ecotalk.SET_INIPOS", STR(pos));
            elem.kin.ErrorReaction(TRUE);
            RETURN;
         END_IF;
         
         IF (elem.kin.handler.partMap[part] <> 0) THEN
            elem.kin.handler.partsIni[part] := pos;
         ELSE
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrPosIniForWrngPrt, elem.kin.kinListInx, 1, 0, "Ecotalk.SET_INIPOS", STR(part));
            elem.kin.ErrorReaction(TRUE);
         END_IF;
      ELSE
         STOPPOINT();
         RcuSetMessageOnce(EcoTalk_ErrCmdActivated, elem.kin.kinListInx, 4, 0, "Ecotalk.SET_INIPOS", "SET_INIPOS");
         elem.kin.ErrorReaction(TRUE);
      END_IF;
   END_IF;
   
END_ROUTINE


// --------------------- E C O T A L K -----------------------------------------
ROUTINE SET_ENDPOS(part : PART; pos : POSITION) GLOBAL USER
                  { macro="HANDLER" | enable="_system.gRcuFocusedRobot.handler.partPosPerHandler" }
   VAR
     elem       : TRcuKinListElem;
   END_VAR
   
   IF RcData.CheckKin(elem, "SET_ENDPOS") THEN
      IF elem.kin.handler.isHandler AND elem.kin.handler.partPosPerHandler THEN
         
         IF elem.kin.handler.hasAdditionalPart THEN // check if functionality is configured
            IF (part = elem.kin.handler.replacingPartNr) THEN
               STOPPOINT();
               RcuSetMessageOnce(EcoTalk_ErrPartPosNDef, elem.kin.kinListInx, 9, 0, "Ecotalk.SET_ENDPOS", STR(part));
               elem.kin.ErrorReaction(TRUE);
            END_IF;
            IF (part = elem.kin.handler.additionalPartNr) THEN
               elem.kin.DebugPrint(eTraceRcuHandler, "SET_ENDPOS, part nr before chg : " + STR(part));
               part := PART(elem.kin.handler.replacingPartNr);
               elem.kin.DebugPrint(eTraceRcuHandler, "SET_ENDPOS, part nr after chg : " + STR(part));
            END_IF;
         END_IF;
         
         IF (part < 1) OR (part > 4) THEN
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrPartPosNDef, elem.kin.kinListInx, 10, 0, "Ecotalk.SET_ENDPOS", STR(part));
            elem.kin.ErrorReaction(TRUE);
            RETURN;
         END_IF;
         IF (pos < 1) OR (pos > 4) THEN
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrPartPosNDef, elem.kin.kinListInx, 11, 0, "Ecotalk.SET_ENDPOS", STR(pos));
            elem.kin.ErrorReaction(TRUE);
            RETURN;
         END_IF;
         IF (elem.kin.handler.partMap[part] <> 0) THEN
            elem.kin.handler.partsEnd[part] := pos;
         ELSE
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrPosIniForWrngPrt, elem.kin.kinListInx, 2, 0, "Ecotalk.SET_ENDPOS", STR(part));
            elem.kin.ErrorReaction(TRUE);
         END_IF;
      ELSE
         STOPPOINT();
         RcuSetMessageOnce(EcoTalk_ErrCmdActivated, elem.kin.kinListInx, 5, 0, "Ecotalk.SET_ENDPOS", "SET_ENDPOS");
         elem.kin.ErrorReaction(TRUE);
      END_IF;
   END_IF;
   
END_ROUTINE


// --------------------- E C O T A L K -----------------------------------------
ROUTINE SET_MODULE(SourcePartTV : PART; SourcePosTV : POSITION; 
                   DestPartTV : PART; DestPosTV : POSITION; modName : STRING) GLOBAL USER 
                   { macro="HANDLER" | enable="_system.gRcuFocusedRobot.handler.partPosPerHandler" }
   VAR
      SourcePartRCU : SINT;                                               
      SourcePosRCU  : SINT;    
      DestPartRCU   : SINT;                                               
      DestPosRCU    : SINT;
      elem          : TRcuKinListElem;
      helpString    : STRING;
      errorTxt      : STRING;
   END_VAR  
   
   IF RcData.CheckKin(elem, "SET_MODULE") THEN
      IF elem.kin.handler.isHandler AND elem.kin.handler.partPosPerHandler THEN
         
         IF elem.kin.handler.hasAdditionalPart THEN // check if functionality is configured
            IF (SourcePartTV = elem.kin.handler.replacingPartNr) THEN
               STOPPOINT();
               RcuSetMessageOnce(EcoTalk_ErrPartPosNDef, elem.kin.kinListInx, 12, 0, "Ecotalk.SET_MODULE", STR(SourcePartTV));
               elem.kin.ErrorReaction(TRUE);
            END_IF;
            IF (SourcePartTV = elem.kin.handler.additionalPartNr) THEN
               elem.kin.DebugPrint(eTraceRcuHandler, "SET_MODULE, source part nr before chg : " + STR(SourcePartTV));
               SourcePartTV := PART(elem.kin.handler.replacingPartNr);
               elem.kin.DebugPrint(eTraceRcuHandler, "SET_MODULE, source part nr after chg : " + STR(SourcePartTV));
            END_IF;
            IF (DestPartTV = elem.kin.handler.replacingPartNr) THEN
               STOPPOINT();
               RcuSetMessageOnce(EcoTalk_ErrPartPosNDef, elem.kin.kinListInx, 13, 0, "Ecotalk.SET_MODULE", STR(DestPartTV));
               elem.kin.ErrorReaction(TRUE);
            END_IF;
            IF (DestPartTV = elem.kin.handler.additionalPartNr) THEN
               elem.kin.DebugPrint(eTraceRcuHandler, "SET_MODULE, dest part nr before chg : " + STR(DestPartTV));
               DestPartTV := PART(elem.kin.handler.replacingPartNr);
               elem.kin.DebugPrint(eTraceRcuHandler, "SET_MODULE, dest part nr after chg : " + STR(DestPartTV));
            END_IF;
         END_IF;
         
         IF (SourcePartTV >= 0) AND (SourcePartTV <= 4) THEN
            SourcePartRCU := SourcePartTV;
         ELSE
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrPartPosNDef, elem.kin.kinListInx, 14, 0, "Ecotalk.SET_MODULE", STR(SourcePartTV));
            elem.kin.ErrorReaction(TRUE);
            RETURN;
         END_IF;

         IF (DestPartTV >= 0) AND (DestPartTV <= 4) THEN
            DestPartRCU := DestPartTV;
         ELSE
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrPartPosNDef, elem.kin.kinListInx, 15, 0, "Ecotalk.SET_MODULE", STR(DestPartTV));
            elem.kin.ErrorReaction(TRUE);
            RETURN;
         END_IF;

         IF (SourcePosTV >= 0) AND (SourcePosTV <= 4) THEN
            SourcePosRCU := SourcePosTV;
         ELSIF (SourcePosTV = 5) THEN
            SourcePartRCU := 0;
            SourcePosRCU  := 0;
         ELSE
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrPartPosNDef, elem.kin.kinListInx, 16, 0, "Ecotalk.SET_MODULE", STR(SourcePosTV));
            elem.kin.ErrorReaction(TRUE);
            RETURN;
         END_IF;

         IF (DestPosTV >= 0) AND (DestPosTV <= 4) THEN
            DestPosRCU := DestPosTV;
         ELSIF (DestPosTV = 5) THEN
            DestPartRCU := 0;
            DestPosRCU  := 0;
         ELSE
            STOPPOINT();
            RcuSetMessageOnce(EcoTalk_ErrPartPosNDef, elem.kin.kinListInx, 17, 0, "Ecotalk.SET_MODULE", STR(DestPosTV));
            elem.kin.ErrorReaction(TRUE);
            RETURN;
         END_IF;

         helpString := StrLeft(elem.kin.handler.mainProg, StrFindRight(elem.kin.handler.mainProg,"."));
         
         modName := helpString + modName;
         IF (elem.kin.handler.yModuleNames[SourcePartRCU] [SourcePosRCU] [DestPartRCU] [DestPosRCU].sName <> "")
            AND (elem.kin.handler.yModuleNames[SourcePartRCU] [SourcePosRCU] [DestPartRCU] [DestPosRCU].sName <> modName) THEN
            errorTxt := "Part=" + STR(SourcePartRCU) + ", Pos=" + STR(SourcePosRCU) + ", --> Part=" + STR(DestPartRCU) + " Pos=" + STR(DestPosRCU);
            RcuSetMessageOnce(EcoTalk_ErrRepeatedDefinition, elem.kin.kinListInx, 1, 0, "Ecotalk.SET_MODULE", errorTxt);
         END_IF;
         elem.kin.handler.yModuleNames[SourcePartRCU] [SourcePosRCU] [DestPartRCU] [DestPosRCU].sName := modName;
      ELSE
         STOPPOINT();
         RcuSetMessageOnce(EcoTalk_ErrCmdActivated, elem.kin.kinListInx, 6, 0, "Ecotalk.SET_MODULE", "SET_MODULE");
         elem.kin.ErrorReaction(TRUE);
      END_IF;
   END_IF;
   
END_ROUTINE


//-----------------------------------------------------------------------------
// Wait until handler goes to respectively leaves handler state
//-----------------------------------------------------------------------------
ROUTINE WAIT_HANDLER_STATE(handler : HANDLER; state : TRcuHandlerState) GLOBAL USER 
                          { macro="HANDLER" | enable="_system.gRcuFocusedRobot.handler.partPosPerHandler" }
   VAR
      iLine   : DINT;
      elem    : TRcuKinListElem; // element with the kinematicreference
      info    : TUserProgStackInfo;
   END_VAR
   
   IF RcData.CheckKin(elem, "WAIT_HANDLER_STATE") THEN
      STOPPOINT();
      IF elem.kin.handler.partPosPerHandler THEN
         //Get Line of Teachprog for Error-Msg
         IF GetUserProgCallStackInfo(0, info) THEN
            IF info.depth > 0 THEN
               iLine := info.lineNrs[info.depth-1];
            ELSE
               iLine := info.lineNrs[0];
            END_IF;
         END_IF;
         CASE state OF
            IsNotHandler : CASE handler OF
                              0 : elem.kin.handler.JobNotRunningFromPLC(0);
                              1 : elem.kin.handler.JobNotRunningFromPLC(1);
                              2 : elem.kin.handler.JobNotRunningFromPLC(2);
                              3 : elem.kin.handler.JobNotRunningFromPLC(3);
                           END_CASE;
            IsHandler    : CASE handler OF
                              0 : elem.kin.handler.JobRunningFromPLC(0);
                              1 : elem.kin.handler.JobRunningFromPLC(1);
                              2 : elem.kin.handler.JobRunningFromPLC(2);
                              3 : elem.kin.handler.JobRunningFromPLC(3);
                           END_CASE;
         END_CASE;
      ELSE
         RcuSetMessageOnce(EcoTalk_ErrCmdActivated, elem.kin.kinListInx, 7, 0, "Ecotalk.WAIT_HANDLER_STATE", "WAIT_HANDLER_STATE");
         elem.kin.ErrorReaction(TRUE);
      END_IF;
   END_IF;
   
END_ROUTINE


// --------------------- E C O T A L K -----------------------------------------
ROUTINE SET_SENSOR(Unit : UNIT; Order : ORDER; OPTIONAL GainVal : GAIN; 
                   OPTIONAL Cycles : SINT) GLOBAL USER { macro="HANDLER" | enable="_system.gRcuFocusedRobot.handler.tool.bEnabled" }
  VAR
    elem : TRcuKinListElem; // element with the kinematicreference
  END_VAR
   
   IF RcData.CheckKin(elem, "SET_SENSOR") THEN
      IF (Unit >= 0) AND (Unit < 3) THEN
         CASE Order OF
           Calibrate:   //MainRun
                   elem.kin.handler.tool.MacroCalibrateSensor(Unit);
           Gain:        //synchron to MainRun
                   elem.kin.handler.tool.MacroSetSensorGain(Unit, GainVal);
           SearchCycle: //synchron to MainRun
                   START elem.kin.handler.tool.MacroSetSearchCycles(Unit, Cycles);
         ELSE
            RcuSetMessageOnce(EcoTalk_WarInvalidOrder, elem.kin.kinListInx, 1, 0, "Ecotalk.SET_SENSOR", STR(Order));
            elem.kin.ErrorReaction(TRUE);
         END_CASE;
      ELSE
        RcuSetMessageOnce(EcoTalk_WarInvalidUnit, elem.kin.kinListInx, 1, 0, "Ecotalk.SET_SENSOR", STR(Unit + 1));
        elem.kin.ErrorReaction(TRUE);
      END_IF;
   END_IF;
   
END_ROUTINE


// --------------------- E C O T A L K -----------------------------------------
ROUTINE SET_CHECK(Unit : UNIT; Order : ORDER; 
                  OPTIONAL VAR_IN Value : SENSORVALUE) GLOBAL USER 
                  { macro="HANDLER" | enable="_system.gRcuFocusedRobot.handler.tool.bEnabled" }
  VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "SET_CHECK") THEN
      IF (Unit >= 0) AND (Unit < 3) THEN
         CASE Order OF
           MaxLimit:    //synchron to MainRun
                START elem.kin.handler.tool.MacroStartStopMaxCheck(Unit, Value, TRUE);                
           MaxLimitOff: //synchron to MainRun
                START elem.kin.handler.tool.MacroStartStopMaxCheck(Unit, Value, FALSE);
           MinLimit:    //synchron to MainRun
                START elem.kin.handler.tool.MacroStartStopMinCheck(Unit, Value, TRUE);
           MinLimitOff: //synchron to MainRun
                START elem.kin.handler.tool.MacroStartStopMinCheck(Unit, Value, FALSE);
           CheckPart:   //synchron to MainRun
                START elem.kin.handler.tool.MacroStartCheckPart(Unit, Value);
         ELSE
            RcuSetMessageOnce(EcoTalk_WarInvalidOrder, elem.kin.kinListInx, 2, 0, "Ecotalk.SET_CHECK", STR(Order));
            elem.kin.ErrorReaction(TRUE);
         END_CASE;
      ELSE
        RcuSetMessageOnce(EcoTalk_WarInvalidUnit, elem.kin.kinListInx, 2, 0, "Ecotalk.SET_CHECK", STR(Unit + 1));
        elem.kin.ErrorReaction(TRUE);
      END_IF;
   END_IF;

END_ROUTINE


// --------------------- E C O T A L K -----------------------------------------
ROUTINE GET_PART(Unit : UNIT; Order : ORDER; OPTIONAL Value : SENSORVALUE) : BOOL GLOBAL USER 
                 { macro="HANDLER" | enable="_system.gRcuFocusedRobot.handler.tool.bEnabled" }
  VAR
    elem : TRcuKinListElem; // element with the kinematicreference
  END_VAR
   
   IF RcData.CheckKin(elem, "GET_PART") THEN  
    IF (Unit >= 0) AND (Unit < 3) THEN
         CASE Order OF
            CheckPart:
               RETURN (elem.kin.handler.tool.MacroGetPartPresent(Unit, Value));
            Stop:
               START elem.kin.handler.tool.MacroStopPartCheck(Unit);
               RETURN TRUE;
          ELSE
            RcuSetMessageOnce(EcoTalk_WarInvalidOrder, elem.kin.kinListInx, 3, 0, "Ecotalk.GET_PART", STR(Order));
            elem.kin.ErrorReaction(TRUE);
            RETURN FALSE;
         END_CASE;
     ELSE
        RcuSetMessageOnce(EcoTalk_WarInvalidUnit, elem.kin.kinListInx, 3, 0, "Ecotalk.GET_PART", STR(Unit + 1));
        elem.kin.ErrorReaction(TRUE);
        RETURN FALSE;
     END_IF;
   ELSE
     RETURN FALSE;
  END_IF;
   
END_ROUTINE

// --------------------- E C O T A L K -----------------------------------------
ROUTINE GET_SEARCH_CNT(Unit : UNIT) : DINT GLOBAL USER { macro="HANDLER" | enable="_system.gRcuFocusedRobot.handler.tool.bEnabled" }
  VAR
    elem : TRcuKinListElem; // element with the kinematicreference
  END_VAR
   
   IF RcData.CheckKin(elem, "GET_SEARCH_CNT") THEN  
      IF (Unit >= 0) AND (Unit < 3) THEN
         RETURN elem.kin.handler.tool.MacroGetSearchCnt(Unit);
      ELSE
        RcuSetMessageOnce(EcoTalk_WarInvalidUnit, elem.kin.kinListInx, 4, 0, "Ecotalk.GET_SEARCH_CNT", STR(Unit + 1));
        RETURN 0;
      END_IF;
   ELSE
      RETURN 0;
   END_IF;   

END_ROUTINE

// --------------------- E C O T A L K -----------------------------------------
ROUTINE PART_SHIFT(Unit : UNIT; Shift : SSHIFT) GLOBAL USER { macro="HANDLER" | enable="_system.gRcuFocusedRobot.handler.tool.bEnabled" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
      lShift : SSHIFT;
   END_VAR
   
   IF RcData.CheckKin(elem, "SEARCH_SHIFT") THEN  
      IF (Unit >= 0) AND (Unit < 3) THEN
         //add handler shift to current shift of the kinematic
         IF NOT elem.kin.handler.tool.GetManualLearningActive(Unit) THEN
            lShift.X_mm  := elem.kin.handler.tool.sKinShift.X_mm  + Shift.X_mm;
            lShift.Y_mm  := elem.kin.handler.tool.sKinShift.Y_mm  + Shift.Y_mm;
            lShift.Z_mm  := elem.kin.handler.tool.sKinShift.Z_mm  + Shift.Z_mm;
            lShift.A7_mm := elem.kin.handler.tool.sKinShift.A7_mm + Shift.A7_mm;
            elem.kin.ActShift := lShift;
            elem.kin.handler.tool.SetPartShiftActive(Unit, Shift);
            START ShiftInMainrun(elem.kin, lShift);
         END_IF;
      ELSE
        RcuSetMessageOnce(EcoTalk_WarInvalidUnit, elem.kin.kinListInx, 4, 0, "Ecotalk.PART_SHIFT", STR(Unit + 1));
        elem.kin.ErrorReaction(TRUE);
        RETURN;
      END_IF;   
   END_IF;
   
END_ROUTINE

// --------------------- E C O T A L K -----------------------------------------
ROUTINE CHECK_TORQUE(Order : TORQUEORDER; Activate : TORQUECHECK; Axis : INT; Boundary : REAL; OnlyMonitoring : BOOL)
        GLOBAL USER { macro="HANDLER" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "CHECK_TORQUE") THEN
      CASE Order OF
         ObserveMaxLimit:
            IF (Activate = StartCheck) THEN
               START PaintRobot[elem.kin.kinListInx].torqueCheck.MacroStartStopMaxCheck(Axis, Boundary, TRUE, OnlyMonitoring);
            ELSIF (Activate = StopCheck) THEN
               START PaintRobot[elem.kin.kinListInx].torqueCheck.MacroStartStopMaxCheck(Axis, Boundary, FALSE, OnlyMonitoring);
            END_IF;
         ObserveMinLimit:
            IF (Activate = StartCheck) THEN
               START PaintRobot[elem.kin.kinListInx].torqueCheck.MacroStartStopMinCheck(Axis, Boundary, TRUE, OnlyMonitoring);
            ELSIF (Activate = StopCheck) THEN
               START PaintRobot[elem.kin.kinListInx].torqueCheck.MacroStartStopMinCheck(Axis, Boundary, FALSE, OnlyMonitoring);
            END_IF;
         PartDetectPosDir:
            IF (Activate = StartCheck) THEN
               START PaintRobot[elem.kin.kinListInx].torqueCheck.MacroStartStopPartDetect(1, Axis, Boundary, TRUE, OnlyMonitoring);
            ELSIF (Activate = StopCheck) THEN
               START PaintRobot[elem.kin.kinListInx].torqueCheck.MacroStartStopPartDetect(1, Axis, Boundary, FALSE, OnlyMonitoring);
            END_IF;
         PartDetectNegDir:
            IF (Activate = StartCheck) THEN
               START PaintRobot[elem.kin.kinListInx].torqueCheck.MacroStartStopPartDetect(-1, Axis, Boundary, TRUE, OnlyMonitoring);
            ELSIF (Activate = StopCheck) THEN
               START PaintRobot[elem.kin.kinListInx].torqueCheck.MacroStartStopPartDetect(-1, Axis, Boundary, FALSE, OnlyMonitoring);
            END_IF;
      ELSE
         RcuSetMessageOnce(EcoTalk_WarInvalidOrder, elem.kin.kinListInx, 4, 0, "Ecotalk.CHECK_TORQUE", STR(Order));
      END_CASE;
   END_IF;
   
END_ROUTINE


// --------------------- E C O T A L K -----------------------------------------
ROUTINE TORQUEMONITOR(Command : STARTSTOP; AxisNumber : AXISNAME)
        GLOBAL USER { macro="OTHER" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "TORQUEMONITOR") THEN
      IF (Command = StartLogging) THEN
         START PaintRobot[elem.kin.kinListInx].torqueLogger.MacroStartStopLogging(TRUE, AxisNumber);
      ELSIF (Command = StopLogging) THEN
         START PaintRobot[elem.kin.kinListInx].torqueLogger.MacroStartStopLogging(FALSE, AxisNumber);
      ELSE
         RcuSetMessageOnce(EcoTalk_WarInvalidOrder, elem.kin.kinListInx, 4, 0, "Ecotalk.TORQUEMONITOR", STR(Command),STR(AxisNumber));
      END_IF;
   END_IF;
   
END_ROUTINE


// --------------------- E C O T A L K -----------------------------------------
ROUTINE ACTIVATE_PAC(Command : PACCCOMMAND)
        GLOBAL USER { macro="CHECKER" | enable="_system.gRcuFocusedRobot.paintChecker.type <> eRcuPaintCheckerOff" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR

   IF RcData.CheckKin(elem, "ACTIVATE_PAC") THEN
      IF (PaintRobot[elem.kin.kinListInx].paintChecker.type <> eRcuPaintCheckerOff) THEN
         IF (Command = Enable) OR (Command = Disable) THEN
            START PaintRobot[elem.kin.kinListInx].paintChecker.MacroEnableDisable(Command = Enable);
         ELSIF (Command = AllPoints) OR (Command = OneShot) THEN
            START PaintRobot[elem.kin.kinListInx].paintChecker.MacroSetMeasOption(Command = OneShot);
         ELSIF (Command = WriteFile) THEN
            START PaintRobot[elem.kin.kinListInx].paintChecker.MacroWriteDataToFile();
         ELSE
            RcuSetMessageOnce(EcoTalk_WarInvalidOrder, elem.kin.kinListInx, 4, 0, "Ecotalk.ACTIVATE_PAC", STR(Command));
         END_IF;
      ELSE
         RcuSetMessageOnce(EcoTalk_WarInvalidOrder, elem.kin.kinListInx, 4, 0, "Ecotalk.ACTIVATE_PAC", STR(Command));
      END_IF;
   END_IF;   
END_ROUTINE


(******************************************************************************************************************
******************   Group  OTHER in Teachview - menu  ************************************************************
******************************************************************************************************************)

ROUTINE RSELECT(name : STRING) GLOBAL USER { macro="OTHER" }
   VAR
      i      : INT;
      bFound : BOOL;
      hnd    : DINT;
      cnt    : DINT;
      prog   : STRING;
   END_VAR
   
   i := 0;
   bFound := FALSE;
   WHILE (i < cgiRcuMaxKinematics) AND NOT bFound DO
      IF IS_MAPPED(gRcuKinList[i].kin) THEN
         IF gRcuKinList[i].kin.robotName = name THEN
            IF (gRcuKinList[i].kin.selectingFlow.flowId = GetProgHdl()) AND gRcuKinList[i].kin.selectingFlow.present THEN
               gRcuKinList[i].kin.iSubSelectLevels := gRcuKinList[i].kin.iSubSelectLevels + 1;
               START gRcuKinList[i].kin.SetSelectLevelInMainRun(gRcuKinList[i].kin.iSubSelectLevels);
               //PRINT("SUBSELECT "+STR(gRcuKinList[i].kin.iSubSelectLevels));
            ELSE
               IF (gRcuKinList[i].kin.kinListInx = gRcuFocusedKinematic.kinListInx)
                  OR gRcuKinList[i].kin.mainModeMgr.externControl  THEN
                  IF gRcuKinList[i].kin.handler.isHandler AND gRcuKinList[i].kin.handler.bJobRunning THEN
                     gRcuKinList[i].kin.bReleaseBlockedByHandler := TRUE;
                  END_IF;
                  gRcuKinList[i].kin.Select();
                  IF NOT gRcuKinList[i].kin.bReleaseBlockedByHandler THEN
                     hnd := GetProgHdl();
                     GetNameFromProgHdl(hnd, prog);
                     gRcuKinList[i].kin.handler.SetProgHandleAndName(hnd, prog);
                  END_IF;
                  gRcuKinList[i].kin.bReleaseBlockedByHandler := FALSE;
               ELSE
                  PRINT("Kinematik nicht angewhlt"); // ERROR
                  hnd := GetProgHdl();
                  InterruptProg(hnd);
               END_IF;
            END_IF;
            IF gRcuKinList[i].kin.handler.isHandler AND gRcuKinList[i].kin.handler.bJobRunning THEN
               START gRcuKinList[i].kin.SetStartTimerInMainRun(gRcuKinList[i].kin.handler.progLevel);
            ELSE
               START gRcuKinList[i].kin.SetStartTimerInMainRun(gRcuKinList[i].kin.iSubSelectLevels);
            END_IF;
            DebugPrint(eTraceCommon, "RSELECT " + name + " " + STR(gRcuKinList[i].kin.iSubSelectLevels));
            bFound := TRUE;
            // wait for next tick to avoid a jitter in program execution
            // because of not reproducible points of interrupt by higher prior tasks
            cnt := gRcuKinList[i].kin.actExecData.mUpdateCounterMain;
            WAIT cnt <> gRcuKinList[i].kin.actExecData.mUpdateCounterMain;
            IF gDoRuntimeVerification THEN
               RuntimeVerification(gRcuKinList[i].kin, "RSELECT", 19, FALSE, 0);
            END_IF;
         END_IF;
      END_IF;
      i := i + 1; 
   END_WHILE;
   
   IF NOT bFound THEN
      RcuSetMessageOnce(EcoTalk_ErrKinNameUnkn, -1, 1, 0, "Ecotalk.RSELECT", name);
   END_IF;
END_ROUTINE


ROUTINE RDESELECT(name : STRING) GLOBAL USER { macro="OTHER" }
   VAR
      i        : INT;
      bFound   : BOOL;
      hdl      : DINT;
      flag     : BOOL;
      progName : STRING;
   END_VAR
   
   i := 0;
   bFound := FALSE;
   WHILE (i < cgiRcuMaxKinematics) AND NOT bFound DO
      IF IS_MAPPED(gRcuKinList[i].kin) THEN
         IF gRcuKinList[i].kin.robotName = name THEN
            DebugPrint(eTraceCommon, "RDESELECT " + name + " " + STR(gRcuKinList[i].kin.iSubSelectLevels));
            IF (gRcuKinList[i].kin.selectingFlow.flowId = GetProgHdl()) AND gRcuKinList[i].kin.selectingFlow.present THEN
//               IF gRcuKinList[i].kin.iSubSelectLevels > 0 THEN
               IF (gRcuKinList[i].kin.iSubSelectLevels > 0) AND NOT gRcuKinList[i].kin.homing.bStopAtEndOfModule 
                  AND NOT gRcuKinList[i].kin.homing.bSigAtEndOfModule THEN
                  START gRcuKinList[i].kin.SetStopTimerInMainRun(gRcuKinList[i].kin.iSubSelectLevels);
                  gRcuKinList[i].kin.iSubSelectLevels := gRcuKinList[i].kin.iSubSelectLevels - 1;
                  START gRcuKinList[i].kin.SetSelectLevelInMainRun(gRcuKinList[i].kin.iSubSelectLevels);
               ELSE
                  STOPPOINT();
                  gRcuKinList[i].kin.iSubSelectLevels := 0;
                  IF gRcuKinList[i].kin.handler.isHandler AND gRcuKinList[i].kin.handler.bJobRunning THEN
                     gRcuKinList[i].kin.bReleaseBlockedByHandler := TRUE;
                     IF NOT (gRcuKinList[i].kin.handler.progLevel = -1) THEN
                        START gRcuKinList[i].kin.SetStopTimerInMainRun(gRcuKinList[i].kin.handler.progLevel);
                     END_IF;
                  ELSE
                     START gRcuKinList[i].kin.SetStopTimerInMainRun(gRcuKinList[i].kin.iSubSelectLevels);
                  END_IF;
                  DESELECT gRcuKinList[i].kin;
                  gRcuKinList[i].kin.bReleaseBlockedByHandler := FALSE;
                  IF gRcuKinList[i].kin.homing.bStopAtEndOfModule THEN
                     hdl := GetProgHdl();
                     GetNameFromProgHdl(hdl, progName);
                     gRcuKinList[i].kin.homing.bEndOfModule := TRUE;
                     gRcuKinList[i].kin.DebugPrint(eTraceHoming, "RDESELECT Homing: StopProg() at end of module '"+progName+"'");
                     IF hdl <> 0 THEN
                        flag := FALSE;
                        StopProgSignal(hdl, flag);
                     END_IF;
                  ELSIF gRcuKinList[i].kin.homing.bSigAtEndOfModule THEN
                     gRcuKinList[i].kin.homing.bEndOfModule := TRUE;
                  END_IF;
               END_IF;
            ELSE // why this else?? NOT selectiongFlow.present?
               STOPPOINT();
               IF gRcuKinList[i].kin.handler.isHandler AND gRcuKinList[i].kin.handler.bJobRunning THEN
                  gRcuKinList[i].kin.bReleaseBlockedByHandler := TRUE;
                  IF NOT (gRcuKinList[i].kin.handler.progLevel = -1) THEN
                     START gRcuKinList[i].kin.SetStopTimerInMainRun(gRcuKinList[i].kin.handler.progLevel);
                  END_IF;
               ELSE
                  START gRcuKinList[i].kin.SetStopTimerInMainRun(gRcuKinList[i].kin.iSubSelectLevels);
               END_IF;
               DESELECT gRcuKinList[i].kin;
               gRcuKinList[i].kin.bReleaseBlockedByHandler := FALSE;
            END_IF;
            bFound := TRUE;
         END_IF;
      END_IF;
      i := i + 1; 
   END_WHILE;
   
   IF NOT bFound THEN
      RcuSetMessageOnce(EcoTalk_ErrKinNameUnkn, -1, 2, 0, "Ecotalk.RDESELECT", name);
   END_IF;
END_ROUTINE


//------------------------------------------------------------------------------
// Lock the specified workspace, setting equal bit to PLC (Executed in Mainrun)
//------------------------------------------------------------------------------
ROUTINE SET(BitNr : IONAME; State : IOTYPE) GLOBAL USER { macro="OTHER" }
VAR
   elem    : TRcuKinListElem;
    iLine   : DINT;
    info    : TUserProgStackInfo;
END_VAR
 
   IF RcData.CheckKin(elem, "SET") THEN
      IF elem.kin.homing.SimulateMacro("SET") THEN
         RETURN;
      END_IF;
      IF (BitNr >= 1) AND (BitNr <= 16) THEN
         START SetCollisionInMainRun(BitNr, State);
      ELSIF (BitNr >= 100) AND (BitNr <= 115) THEN
         START SetCustomBitsInMainRun(BitNr, State);
      ELSIF (BitNr >= 17) AND (BitNr <= 54) THEN
         CASE BitNr OF
            //Multiobject Visionsystem
            22  :  START elem.kin.vision.MacroSetOrder(1); 
            
            23  :  START elem.kin.vision.MacroSetOrder(2);

            24  :  START elem.kin.vision.MacroSetOrder(3);
                            
            25  :  START elem.kin.vision.MacroSetOrder(4);
                            
            26  :  START elem.kin.vision.MacroSetOrder(5);
                           
            27  :  START elem.kin.vision.MacroSetOrder(6);
            
            28  :  START elem.kin.vision.MacroSetOrder(7);
            
            29  :  START elem.kin.vision.MacroSetOrder(8);
         
            30  :  START elem.kin.vision.MacroSetOrder(9);

            31  :  START elem.kin.vision.MacroSetOrder(10);

            32  :  START elem.kin.vision.MacroSetOrder(11);

            33  :  START elem.kin.vision.MacroSetOrder(12);

            34  :  START elem.kin.vision.MacroSetOrder(13);

            35  :  START elem.kin.vision.MacroSetOrder(14);

            36  :  START elem.kin.vision.MacroSetOrder(15);

            37  :  START elem.kin.vision.MacroSetOrder(16);

            38  :  START elem.kin.vision.MacroSetJob(1);
                     
            39  :  START elem.kin.vision.MacroSetJob(2);
            
            40  :  START elem.kin.vision.MacroSetJob(3);
         
            41  :  elem.kin.vision.MacroStartProgram(0);
                             
            42  :  elem.kin.vision.MacroStartProgram(1);
                           
            43  :  elem.kin.vision.MacroStartProgram(2);
                           
            44  :  elem.kin.vision.MacroStartProgram(3);

            45  :  elem.kin.vision.MacroStartProgram(4);

            46  :  elem.kin.vision.MacroStartProgram(5);

            47  :  elem.kin.vision.MacroStartProgram(6);

            48  :  elem.kin.vision.MacroStartProgram(7);

            49  :  elem.kin.vision.MacroStartProgram(8);

            50  :  elem.kin.vision.MacroStartProgram(9);

            51  :  START elem.kin.vision.MacroSetEndOfPath();
            
            52  :  START elem.kin.vision.MacroSetOnlineCorr(State);
           
            53  :  elem.kin.vision.MacroSetOrder(17);
            
            54  :  elem.kin.vision.MacroSetOrder(18);
           
           //extension for ISRA-Stereohead DC-Bremen 06.12.06 BIT
            19   :  START elem.kin.vision.MacroSetMeasurePos(FALSE);
                  
            20   :  START elem.kin.vision.MacroSetMeasurePos(TRUE);
            ELSE
               IF GetUserProgCallStackInfo(0, info) THEN
                  IF info.depth > 0 THEN
                     iLine := info.lineNrs[info.depth-1]; 
                  ELSE
                     iLine := info.lineNrs[0];
                  END_IF;
               END_IF;
               RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 1, 0, "Ecotalk.SET", STR(iLine), "SET", STR(BitNr));
               elem.kin.ErrorReaction(TRUE);
         END_CASE;
      END_IF;
   END_IF;
END_ROUTINE


//-----------------------------------------------------------------------------
// Setting bits to mainrun
//-----------------------------------------------------------------------------
ROUTINE SetCustomBitsInMainRun(Pin : IONAME; State : IOTYPE) PRIVATE
 VAR
   bIn     : BOOL;
   elem    : TRcuKinListElem;
 END_VAR

   IF RcData.CheckKin(elem, "SetCustomBitsInMainRun") THEN
      MAINRUN();
      CASE State OF
         High : bIn := TRUE;
         Low  : bIn := FALSE;
      ELSE
         PRINT("ERROR - Wrong state for Job");
      END_CASE;
      CASE Pin OF
       0 : PRINT("ERROR - Wrong Job for this Macro");
      ELSE
         elem.kin.autoControl.SetCustomBit(Pin, bIn);
      END_CASE;
   END_IF;
   
END_ROUTINE


//-----------------------------------------------------------------------------
// Lock the specified workspace according to mainrun, setting equal bit to PLC
//-----------------------------------------------------------------------------
ROUTINE SetCollisionInMainRun(Pin : IONAME; State : IOTYPE) PRIVATE
 VAR
   bIn     : BOOL;
   elem    : TRcuKinListElem;
 END_VAR

   IF RcData.CheckKin(elem, "SetCollisionInMainRun") THEN
      MAINRUN();
      CASE State OF
         High : bIn := TRUE;
         Low  : bIn := FALSE;
      ELSE
         PRINT("ERROR - Wrong state for Job");
      END_CASE;
      CASE Pin OF
       0 : PRINT("ERROR - Wrong Job for this Macro");
      ELSE
         elem.kin.autoControl.SetCollision(Pin, bIn);
         elem.kin.DebugPrint(eTraceAutoControl, "Set collision Pin = " + STR(Pin) + "State = " + STR(bIn));
      END_CASE;
   END_IF;
   
END_ROUTINE


ROUTINE SET_CAMPOS(PosNr : BYTE) GLOBAL USER { macro="OTHER" }
VAR
   elem    : TRcuKinListElem; // element with the kinematicreference
END_VAR

   IF RcData.CheckKin(elem, "SET_CAMPOS") THEN
      IF elem.kin.homing.SimulateMacro("SET_CAMPOS") THEN
         RETURN;
      END_IF;
      elem.kin.vision.MacroSetCamPos(PosNr);
   END_IF;

END_ROUTINE

//-----------------------------------------------------------------------------------------------
// Check if specified workspace is locked,  receiving equal bit from PLC (Executed in Mainrun)
//-----------------------------------------------------------------------------------------------
ROUTINE RECEIVE(Pin : IONAME; State : IOTYPE) : BOOL GLOBAL USER { macro="OTHER" }
 VAR
    bIn     : BOOL;
    elem    : TRcuKinListElem; // element with the kinematicreference
    iLine   : DINT;
    info    : TUserProgStackInfo;
 END_VAR

   IF RcData.CheckKin(elem, "RECEIVE") THEN
      IF elem.kin.homing.SimulateMacro("RECEIVE") THEN
         RETURN TRUE;
      END_IF;
      STOPPOINT();
      IF ((Pin = 17) OR (Pin = 18)) THEN
         CASE State OF
           Data : RETURN elem.kin.vision.MacroReceiveVisionData((Pin = 18));
         ELSE  
            //Get Line of Teachprog for Error-Msg
            IF GetUserProgCallStackInfo(0, info) THEN
               IF info.depth > 0 THEN
                  iLine := info.lineNrs[info.depth-1]; 
               ELSE
                  iLine := info.lineNrs[0];
               END_IF;
            END_IF;
            RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 2, 0, "Ecotalk.RECEIVE", STR(iLine), "RECEIVE", STR(State));
            elem.kin.ErrorReaction(TRUE);
         END_CASE;
      ELSIF (Pin = 21) THEN
         RETURN elem.kin.vision.MacroReceiveNextCamPos();
      ELSIF ((Pin >= 1) AND (Pin <= 16)) THEN   
         CASE State OF
           High : bIn := TRUE;
           Low  : bIn := FALSE;
         ELSE
            //Get Line of Teachprog for Error-Msg
            IF GetUserProgCallStackInfo(0, info) THEN
               IF info.depth > 0 THEN
                  iLine := info.lineNrs[info.depth-1]; 
               ELSE
                  iLine := info.lineNrs[0];
               END_IF;
            END_IF;
            RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 3, 0, "Ecotalk.RECEIVE", STR(iLine), "RECEIVE", STR(State));
            elem.kin.ErrorReaction(TRUE);
         END_CASE;
         elem.kin.DebugPrint(eTraceAutoControl, "Wait for collision Pin = " + STR(Pin) + "State = " + STR(bIn));
         elem.kin.autoControl.ReceiveCollision(Pin, bIn);
         elem.kin.DebugPrint(eTraceAutoControl, "Received collision Pin = " + STR(Pin) + "State = " + STR(bIn));
      ELSIF (Pin >= 100) AND (Pin <= 115) THEN
         CASE State OF
           High : bIn := TRUE;
           Low  : bIn := FALSE;
         ELSE
            //Get Line of Teachprog for Error-Msg
            IF GetUserProgCallStackInfo(0, info) THEN
               IF info.depth > 0 THEN
                  iLine := info.lineNrs[info.depth-1]; 
               ELSE
                  iLine := info.lineNrs[0];
               END_IF;
            END_IF;
            RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 4, 0, "Ecotalk.RECEIVE", STR(iLine), "RECEIVE", STR(State));
            elem.kin.ErrorReaction(TRUE);
         END_CASE;
         elem.kin.autoControl.ReceiveCustomBit(Pin, bIn);
      ELSE
         //Get Line of Teachprog for Error-Msg
         IF GetUserProgCallStackInfo(0, info) THEN
            IF info.depth > 0 THEN
               iLine := info.lineNrs[info.depth-1]; 
            ELSE
               iLine := info.lineNrs[0];
            END_IF;
         END_IF;
         RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 5, 0, "Ecotalk.RECEIVE", STR(iLine), "RECEIVE", STR(Pin));
         elem.kin.ErrorReaction(TRUE);
      END_IF;     
   END_IF;
   RETURN FALSE;
END_ROUTINE


//-----------------------------------------------------------------------------------------------
// Gets bit from PLC
//-----------------------------------------------------------------------------------------------
ROUTINE GET(Pin : IONAME; state : IOTYPE) :  BOOL GLOBAL USER { macro="OTHER" }
 VAR
    bIn     : BOOL;
    varState: BOOL;
    elem    : TRcuKinListElem; // element with the kinematicreference
    iLine   : DINT;
    info    : TUserProgStackInfo;
 END_VAR

   bIn := FALSE;
   IF RcData.CheckKin(elem, "GET") THEN
      IF elem.kin.homing.SimulateMacro("GET") THEN
         RETURN FALSE;
      END_IF;
      CASE state OF
         High : varState := TRUE;
         Low  : varState := FALSE;
      ELSE
         STOPPOINT();
         RcuSetMessageOnce(EcoTalk_ErrInvalidValue, elem.kin.kinListInx, 16, 0, "Ecotalk.GET", "state = Data");
         RETURN FALSE;
      END_CASE;
      IF NOT elem.kin.progPath.bAppendLate THEN  
         STOPPOINT();
      END_IF;
      IF (Pin >= 100) AND (Pin <= 115) THEN
         bIn := elem.kin.autoControl.GetCustomBit(Pin);
      ELSE
         //Get Line of Teachprog for Error-Msg
        STOPPOINT();
         IF GetUserProgCallStackInfo(0, info) THEN
            IF info.depth > 0 THEN
               iLine := info.lineNrs[info.depth-1]; 
            ELSE
               iLine := info.lineNrs[0];
            END_IF;
         END_IF;
         RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 6, 0, "Ecotalk.GET", STR(iLine), "GET", STR(Pin));
         elem.kin.ErrorReaction(TRUE);
      END_IF;     
   END_IF;
   RETURN (bIn = varState);
END_ROUTINE


//-----------------------------------------------------------------------------------------------
// Identification which robot is in "Degrade-Mode" received from BCU-Fifo (Executed in Prerun)
//-----------------------------------------------------------------------------------------------
ROUTINE GET_DEGRADE_MODE(DegradeRob : DEGRADEROB) : BOOL GLOBAL USER { macro="OTHER" }
  VAR
    i       : DINT;
    iLine   : DINT;
    elem    : TRcuKinListElem; // element with the kinematicreference
    info    : TUserProgStackInfo;
  END_VAR
  
  IF RcData.CheckKin(elem, "GET_DEGRADE_MODE") THEN
     i := DEGRADEROB(DegradeRob);
     IF (i < 1) OR (i > 16) THEN
       //Get Line of Teachprog for Error-Msg
       IF GetUserProgCallStackInfo(0, info) THEN
          IF info.depth > 0 THEN
             iLine := info.lineNrs[info.depth-1]; 
          ELSE
             iLine := info.lineNrs[0];
          END_IF;
       END_IF;
       STOPPOINT();
       RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 7, 0, "Ecotalk.GET_DEGRADE_MODE", STR(iLine), "DEGRADEROB", STR(i));
       elem.kin.ErrorReaction(TRUE);
       RETURN FALSE; 
     ELSE
        RETURN elem.kin.autoControl.GetDegradeMode(i);
     END_IF;
  END_IF;  
  RETURN FALSE;  //default robot shouldn't move degrade-program
END_ROUTINE


//-----------------------------------------------------------------------------
// Get the Paintvariant received from BCU-Fifo (Executed in Prerun)
//-----------------------------------------------------------------------------
ROUTINE GET_VARIANT(Variant : VARIANT) : BOOL GLOBAL USER { macro="OTHER" }
VAR   
   i       : DINT;
   iLine   : DINT;
   elem    : TRcuKinListElem; // element with the kinematicreference
   info    : TUserProgStackInfo;
END_VAR    
   
  IF RcData.CheckKin(elem, "GET_VARIANT") THEN
     i := VARIANT(Variant);
     IF (i < 1) OR (i >192) OR ((i > 32) AND NOT elem.kin.RcuInterfaceToBCU.bVariantHighMapped 
                                         AND NOT elem.kin.RcuInterfaceToBCU.bVariantExtMapped)
         OR ((i > 64) AND NOT elem.kin.RcuInterfaceToBCU.bVariantExtMapped ) THEN
       //Get Line of Teachprog for Error-Msg
       IF GetUserProgCallStackInfo(0, info) THEN
          IF info.depth > 0 THEN
             iLine := info.lineNrs[info.depth-1]; 
          ELSE
             iLine := info.lineNrs[0]; 
          END_IF;
       END_IF;
       STOPPOINT();
       RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 8, 0, "Ecotalk.GET_VARIANT", STR(iLine), "VARIANT", STR(i));
       elem.kin.ErrorReaction(TRUE);
       RETURN FALSE; 
     ELSE
       RETURN elem.kin.autoControl.GetVariante(i);
     END_IF;
  END_IF;
  RETURN TRUE;
  
END_ROUTINE


//-----------------------------------------------------------------------------
// Get the Repairtype received from BCU-Fifo (Executed in Prerun)
//-----------------------------------------------------------------------------
ROUTINE GET_REPAIRTYPE(RepairType : REPAIRTYPE) : BOOL GLOBAL USER { macro="OTHER" }
  VAR
    i       : DINT;
    iLine   : DINT;
    elem    : TRcuKinListElem; // element with the kinematicreference
    info    : TUserProgStackInfo;
  END_VAR
  
  IF RcData.CheckKin(elem, "GET_REPAIRTYPE") THEN
     i := REPAIRTYPE(RepairType);
     IF (i < 0) OR (i > 192) OR ((i > 32) AND NOT elem.kin.RcuInterfaceToBCU.bPartareasExtMapped ) THEN
       //Get Line of Teachprog for Error-Msg
       IF GetUserProgCallStackInfo(0, info) THEN
          IF info.depth > 0 THEN
             iLine := info.lineNrs[info.depth-1]; 
          ELSE
             iLine := info.lineNrs[0]; 
          END_IF;
       END_IF;
       STOPPOINT();
       RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 9, 0, "Ecotalk.GET_REPAIRTYPE", STR(iLine), "REPAIRTYPE", STR(i));
       elem.kin.ErrorReaction(TRUE);
       RETURN FALSE; 
     ELSE
       RETURN elem.kin.autoControl.GetPartAreas(i);
     END_IF;
  END_IF;  
  RETURN TRUE;
  
END_ROUTINE


//-----------------------------------------------------------------------------
// Set state to Motion for specified group and job
//-----------------------------------------------------------------------------
ROUTINE SET_MOTION_STATE(Group : TRcuMotionGroup; Job : TRcuMotionJob; Run : TRcuPreMainRun) GLOBAL USER { macro="OTHER" }
  VAR
    elem    : TRcuKinListElem; // element with the kinematicreference
    iLine   : DINT;
    info    : TUserProgStackInfo;
  END_VAR
  
  IF RcData.CheckKin(elem, "SET_MOTION_STATE") THEN
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
          iLine := info.lineNrs[info.depth-1]; 
         ELSE
          iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      CASE Run OF
         MainRun  :  START SetMotionState(Group, Job, Run);
         
         PreRun   :  SetMotionState(Group, Job, Run); 
      
         Stopp    :  STOPPOINT();
         SetMotionState(Group, Job, Run);
      ELSE
        RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 10, 0, "Ecotalk.SET_MOTION_STATE",  STR(iLine), "TRcuPreMainRun", STR(Run));
        elem.kin.ErrorReaction(TRUE);  
      END_CASE;

  END_IF;   
 
END_ROUTINE


//----------------------------------------------------------------------------------
// Set state to Motion for specified group and job in Prerun or according to mainrun
//----------------------------------------------------------------------------------
ROUTINE SetMotionState(Group : TRcuMotionGroup; Job : TRcuMotionJob; Run : TRcuPreMainRun) PRIVATE
  VAR
    iLine   : DINT;
    elem    : TRcuKinListElem; // element with the kinematicreference
    info    : TUserProgStackInfo;
  END_VAR
  
  IF RcData.CheckKin(elem, "SetMotionState") THEN
     IF Run = MainRun THEN
        MAINRUN();
     END_IF;
     //Get Line of Teachprog for Error-Msg
     IF GetUserProgCallStackInfo(0, info) THEN
        IF info.depth > 0 THEN
           iLine := info.lineNrs[info.depth-1]; 
        ELSE
           iLine := info.lineNrs[0]; 
        END_IF;
     END_IF;
          
     CASE Group OF
       GrindBrake       :  CASE Job OF
                             Joint1  :  PaintRobot[elem.kin.kinListInx].brakeCheck.yCloseBrakeTeachIn[0] := TRUE;
                             Joint2  :  PaintRobot[elem.kin.kinListInx].brakeCheck.yCloseBrakeTeachIn[1] := TRUE;
                             Joint3  :  PaintRobot[elem.kin.kinListInx].brakeCheck.yCloseBrakeTeachIn[2] := TRUE;
                             Joint4  :  PaintRobot[elem.kin.kinListInx].brakeCheck.yCloseBrakeTeachIn[3] := TRUE;
                             Joint5  :  PaintRobot[elem.kin.kinListInx].brakeCheck.yCloseBrakeTeachIn[4] := TRUE;
                             Joint6  :  PaintRobot[elem.kin.kinListInx].brakeCheck.yCloseBrakeTeachIn[5] := TRUE;
                             Joint7  :  PaintRobot[elem.kin.kinListInx].brakeCheck.yCloseBrakeTeachIn[6] := TRUE;
                             Joint8  :  PaintRobot[elem.kin.kinListInx].brakeCheck.yCloseBrakeTeachIn[7] := TRUE;
                             Joint9  :  PaintRobot[elem.kin.kinListInx].brakeCheck.yCloseBrakeTeachIn[8] := TRUE;
                           ELSE  
                             MAINRUN();
                             RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 1, 0, "Ecotalk.SET_MOTION_STATE", STR(iLine), STR(Job), "GrindBrake");
                             elem.kin.ErrorReaction(TRUE);
                           END_CASE;
                           
       BrakeCheck       :  CASE Job OF
                             Robot  :  PaintRobot[elem.kin.kinListInx].brakeCheck.MacroBrakeCheck();
                           ELSE  
                             RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 2, 0, "Ecotalk.SET_MOTION_STATE", STR(iLine), STR(Job), "BrakeCheck");
                           END_CASE;                    
                           
       TorqueMon        :  CASE Job OF
                             Joint1  :  PRINT("Available soon");
                             Joint2  :  PRINT("Available soon");
                             Joint3  :  PRINT("Available soon");
                             Joint4  :  PRINT("Available soon");
                             Joint5  :  PRINT("Available soon");
                             Joint6  :  PRINT("Available soon");
                             Joint7  :  PRINT("Available soon");
                           ELSE  
                             MAINRUN();
                             RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 3, 0, "Ecotalk.SET_MOTION_STATE", STR(iLine), STR(Job), "TorqueMon");
                             elem.kin.ErrorReaction(TRUE);
                           END_CASE;
       
       InBellCleaner :    CASE Job OF
                             True  : elem.kin.RcuInterfaceToProcess.SetInBellCleaner(TRUE);
                             False : elem.kin.RcuInterfaceToProcess.SetInBellCleaner(FALSE);
                           ELSE  
                             MAINRUN();
                             RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 4, 0, "Ecotalk.SET_MOTION_STATE", STR(iLine), STR(Job), "InBellCleaner");
                             elem.kin.ErrorReaction(TRUE);
                           END_CASE;
       InCapCleaner :     CASE Job OF
                             True  : elem.kin.RcuInterfaceToProcess.SetInCapCleaner(TRUE);
                             False : elem.kin.RcuInterfaceToProcess.SetInCapCleaner(FALSE);
                           ELSE  
                             MAINRUN();
                             RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 4, 0, "Ecotalk.SET_MOTION_STATE", STR(iLine), STR(Job), "InCapCleaner");
                             elem.kin.ErrorReaction(TRUE);
                           END_CASE;
     ELSE  
       MAINRUN();
       RcuSetMessageOnce(EcoTalk_ErrUnknownGroup, elem.kin.kinListInx, 1, 0, "Ecotalk.SET_MOTION_STATE", STR(iLine), STR(Group), "SET_MOTION_STATE");
       elem.kin.ErrorReaction(TRUE);
     END_CASE;    
  END_IF;

END_ROUTINE


//-----------------------------------------------------------------------------
// Get state from Motion for specified group and job
//-----------------------------------------------------------------------------
ROUTINE GET_MOTION_STATE(Group : TRcuMotionGroup; Job : TRcuMotionJob) : BOOL GLOBAL USER { macro="OTHER" }
  VAR
    iLine   : DINT;
    elem    : TRcuKinListElem; // element with the kinematicreference
    info    : TUserProgStackInfo;
  END_VAR
  
  IF RcData.CheckKin(elem, "GET_MOTION_STATE") THEN
    //Get Line of Teachprog for Error-Msg
    IF GetUserProgCallStackInfo(0, info) THEN
       IF info.depth > 0 THEN
          iLine := info.lineNrs[info.depth-1]; 
       ELSE
          iLine := info.lineNrs[0]; 
       END_IF;
    END_IF;
    IF NOT elem.kin.progPath.bAppendLate THEN  
       STOPPOINT();
    END_IF;
    
    CASE Group OF
      InBellCleaner :    CASE Job OF
                           True  : RETURN elem.kin.RcuInterfaceToProcess.GetInBellCleaner(TRUE);
                           False : RETURN elem.kin.RcuInterfaceToProcess.GetInBellCleaner(FALSE);
                         ELSE  
                           STOPPOINT();
                           RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 5, 0, "Ecotalk.GET_MOTION_STATE", STR(iLine), STR(Job), "InBellCleaner");
                           elem.kin.ErrorReaction(TRUE);
                         END_CASE;

      HomingActive :     CASE Job OF
                           True  : RETURN elem.kin.autoControl.GetHomingActive(TRUE);
                           False : RETURN elem.kin.autoControl.GetHomingActive(FALSE);
                         ELSE  
                           STOPPOINT();
                           RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 5, 0, "Ecotalk.GET_MOTION_STATE", STR(iLine), STR(Job), "InBellCleaner");
                           elem.kin.ErrorReaction(TRUE);
                         END_CASE;

    ELSE  
       STOPPOINT();
       RcuSetMessageOnce(EcoTalk_ErrUnknownGroup, elem.kin.kinListInx, 2, 0, "Ecotalk.GET_MOTION_STATE", STR(iLine), STR(Group), "GET_MOTION_STATE");
       elem.kin.ErrorReaction(TRUE);
    END_CASE;
  END_IF;  
  
  RETURN FALSE;
END_ROUTINE


//-----------------------------------------------------------------------------
// Wait until Motion signals requested state for specified group and job
//-----------------------------------------------------------------------------
ROUTINE WAIT_MOTION_STATE(Group : TRcuMotionGroup; Job : TRcuMotionJob) : BOOL GLOBAL USER { macro="OTHER" }
  VAR
    iLine   : DINT;
    elem    : TRcuKinListElem; // element with the kinematicreference
    info    : TUserProgStackInfo;
  END_VAR
  
  IF RcData.CheckKin(elem, "WAIT_MOTION_STATE") THEN
     STOPPOINT();
     //Get Line of Teachprog for Error-Msg
     IF GetUserProgCallStackInfo(0, info) THEN
        IF info.depth > 0 THEN
           iLine := info.lineNrs[info.depth-1]; 
        ELSE
           iLine := info.lineNrs[0]; 
        END_IF;
     END_IF;
     RcuSetMessageOnce(EcoTalk_ErrUnknownGroup, elem.kin.kinListInx, 3, 0, "Ecotalk.WAIT_MOTION_STATE", STR(iLine), STR(Group), "WAIT_MOTION_STATE");
     elem.kin.ErrorReaction(TRUE);
     RETURN FALSE;
  END_IF;
  RETURN FALSE;
  
END_ROUTINE


//-----------------------------------------------------------------------------
// Set state to Process for specified group and job
//-----------------------------------------------------------------------------
ROUTINE SET_PROCESS_STATE(Group : TRcuProcessGroup; Job : TRcuProcessJob; Run : TRcuPreMainRun) GLOBAL USER { macro="OTHER" }
  VAR
    elem    : TRcuKinListElem; // element with the kinematicreference
    iLine   : DINT;
    info    : TUserProgStackInfo;
  END_VAR
  
  IF RcData.CheckKin(elem, "SET_PROCESS_STATE") THEN
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
          iLine := info.lineNrs[info.depth-1]; 
         ELSE
          iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      CASE Run OF
         MainRun   : START SetProcessState(Group, Job, Run);

         PreRun    : SetProcessState(Group, Job, Run);

         Stopp     : STOPPOINT();
         SetProcessState(Group, Job, Run);
      ELSE   
         RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 11, 0, "Ecotalk.SET_PROCESS_STATE",  STR(iLine), "TRcuPreMainRun", STR(Run));
         elem.kin.ErrorReaction(TRUE); 
      END_CASE;
         
  END_IF;  

END_ROUTINE


//----------------------------------------------------------------------------------
// Set state to Motion for specified group and job in Prerun or according to mainrun
//----------------------------------------------------------------------------------
ROUTINE SetProcessState(Group : TRcuProcessGroup; Job : TRcuProcessJob; Run : TRcuPreMainRun) PRIVATE
  VAR
    iLine   : DINT;
    elem    : TRcuKinListElem; // element with the kinematicreference
    info    : TUserProgStackInfo;
  END_VAR
  
  IF RcData.CheckKin(elem, "SetProcessState") THEN
     IF Run = MainRun THEN
        MAINRUN();
     END_IF;
     //Get Line of Teachprog for Error-Msg
     IF GetUserProgCallStackInfo(0, info) THEN
        IF info.depth > 0 THEN
           iLine := info.lineNrs[info.depth-1]; 
        ELSE
           iLine := info.lineNrs[0]; 
        END_IF;
     END_IF;
     CASE Group OF
        AbortBody    :   IF Job = ON THEN
                            elem.kin.RcuInterfaceToBCU.mAbortBody := TRUE;
                         ELSE
                            elem.kin.RcuInterfaceToBCU.mAbortBody := FALSE;
                         END_IF;
        PistonChange :   IF Job = ON THEN
                            elem.kin.RcuInterfaceToProcess.svPistonChange := TRUE;
                         ELSE
                            elem.kin.RcuInterfaceToProcess.svPistonChange := FALSE;
                         END_IF;
        TankStop     :   IF Job = ON THEN
                            elem.kin.RcuInterfaceToProcess.svTankStop := TRUE;
                         ELSE
                            elem.kin.RcuInterfaceToProcess.svTankStop := FALSE;
                         END_IF;
        MD_DeskOrder :   IF PaintRobot[elem.kin.kinListInx].chgMaskingDevice THEN
                            CASE Job OF
                               ON  : PaintRobot[elem.kin.kinListInx].fieldbusOut.MDDeskOrder.svBool := TRUE;
                               OFF : PaintRobot[elem.kin.kinListInx].fieldbusOut.MDDeskOrder.svBool := FALSE;
                            END_CASE;
                         END_IF;
        MD_Cover     :   CASE Job OF
                            ON  : elem.kin.RcuInterfaceToProcess.svCover := TRUE;
                            OFF : elem.kin.RcuInterfaceToProcess.svCover := FALSE;
                         END_CASE;
        MD_Coupling :    CASE Job OF
                            ON  :             elem.kin.RcuInterfaceToProcess.svCoupling := TRUE;
                            OFF :             elem.kin.RcuInterfaceToProcess.svCoupling := FALSE;
                            CouplingErrorOn:  RcuSetMessageOnce(EcoTalk_ErrCouplingOn, elem.kin.kinListInx, 1, 0, "Ecotalk.SET_PROCESS_STATE");
                            CouplingErrorOff: RcuSetMessageOnce(EcoTalk_ErrCouplingOff, elem.kin.kinListInx, 1, 0, "Ecotalk.SET_PROCESS_STATE");
                         END_CASE;
        MD_MaskGripper : IF PaintRobot[elem.kin.kinListInx].chgMaskingDevice THEN
                            CASE Job OF
                               ON  : PaintRobot[elem.kin.kinListInx].fieldbusOut.MDGripperOrder.svBool := TRUE;
                               OFF : PaintRobot[elem.kin.kinListInx].fieldbusOut.MDGripperOrder.svBool := FALSE;
                            END_CASE;
                         END_IF;
     ELSE
        MAINRUN();
        RcuSetMessageOnce(EcoTalk_ErrUnknownGroup, elem.kin.kinListInx, 4, 0, "Ecotalk.SET_PROCESS_STATE", STR(iLine), STR(Group), "SET_PROCESS_STATE");
        elem.kin.ErrorReaction(TRUE);
     END_CASE;
  END_IF;

END_ROUTINE


//-----------------------------------------------------------------------------
// Get state from Process for specified group and job
//-----------------------------------------------------------------------------
ROUTINE GET_PROCESS_STATE(Group : TRcuProcessGroup; Job : TRcuProcessJob) : BOOL GLOBAL USER { macro="OTHER" }
  VAR
    iLine   : DINT;
    elem    : TRcuKinListElem; // element with the kinematicreference
    info    : TUserProgStackInfo;
  END_VAR
  
  IF RcData.CheckKin(elem, "GET_PROCESS_STATE") THEN
    //Get Line of Teachprog for Error-Msg
    IF GetUserProgCallStackInfo(0, info) THEN
       IF info.depth > 0 THEN
          iLine := info.lineNrs[info.depth-1]; 
       ELSE
          iLine := info.lineNrs[0]; 
       END_IF;
    END_IF;
    IF NOT elem.kin.progPath.bAppendLate THEN  
      STOPPOINT();
       RcuSetMessageOnce(EcoTalk_ErrNoAppndLate, elem.kin.kinListInx, 2, 0, "EcoTalk.GET_PROCESS_STATE", STR(iLine), "GET_PROCESS_STATE");
       elem.kin.ErrorReaction(TRUE);
       RETURN FALSE;
    END_IF;
    
    CASE Group OF
       Hightension : CASE Job OF
                        ON  : RETURN elem.kin.RcuInterfaceToProcess.GetHighTension(TRUE);
                        OFF : RETURN elem.kin.RcuInterfaceToProcess.GetHighTension(FALSE);
                     ELSE  
                        STOPPOINT();
                        RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 6, 0, "Ecotalk.GET_PROCESS_STATE", STR(iLine), STR(Job), "Hightension");
                        elem.kin.ErrorReaction(TRUE);
                     END_CASE;
       GoHomeAtEnd : RETURN elem.kin.RcuInterfaceToBCU.mGoHomeAtEnd;
       NoPaint     : RETURN elem.kin.RcuInterfaceToBCU.mNoPaint;
       MD_InUse    : RETURN elem.kin.RcuInterfaceToProcess.svMaskingDeviceInUse;
       MD_AtIni    : RETURN elem.kin.RcuInterfaceToProcess.svMaskingDeviceAtIni;
       PivotingBracketInPos: CASE Job OF
                                ON  : RETURN elem.kin.RcuInterfaceToProcess.GetPivotingBracketPos(TRUE);
                                OFF : RETURN elem.kin.RcuInterfaceToProcess.GetPivotingBracketPos(FALSE);
                             ELSE  
                                STOPPOINT();
                                RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 6, 0, "Ecotalk.GET_PROCESS_STATE", STR(iLine), STR(Job), "PivotingBracketInPos");
                                elem.kin.ErrorReaction(TRUE);
                             END_CASE;
    ELSE
       STOPPOINT();
       RcuSetMessageOnce(EcoTalk_ErrUnknownGroup, elem.kin.kinListInx, 5, 0, "Ecotalk.GET_PROCESS_STATE", STR(iLine), STR(Group), "GET_PROCESS_STATE");
       elem.kin.ErrorReaction(TRUE);
    END_CASE;
  END_IF;  
  
  RETURN FALSE;
END_ROUTINE


//-----------------------------------------------------------------------------
// Wait until Process signals requested state for specified group and job
//-----------------------------------------------------------------------------
ROUTINE WAIT_PROCESS_STATE(Group : TRcuProcessGroup; Job : TRcuProcessJob) : BOOL GLOBAL USER { macro="OTHER" }
  VAR
    iLine   : DINT;
    elem    : TRcuKinListElem; // element with the kinematicreference
    info    : TUserProgStackInfo;
  END_VAR
  
  IF RcData.CheckKin(elem, "WAIT_PROCESS_STATE") THEN
     STOPPOINT();
     //Get Line of Teachprog for Error-Msg
     IF GetUserProgCallStackInfo(0, info) THEN
        IF info.depth > 0 THEN
           iLine := info.lineNrs[info.depth-1]; 
        ELSE
           iLine := info.lineNrs[0]; 
        END_IF;
     END_IF;
     CASE Group OF
        Hightension    : CASE Job OF
                            ON  : elem.kin.RcuInterfaceToProcess.WaitHighTension(FALSE);
                            OFF : elem.kin.RcuInterfaceToProcess.WaitHighTension(TRUE);
                         ELSE
                            RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 7, 0, "Ecotalk.WAIT_PROCESS_STATE", STR(iLine), STR(Job), "Hightension");
                         END_CASE;
        PistonChange   : elem.kin.RcuInterfaceToProcess.WaitPistonChangeFinished();
        TankStop       : elem.kin.RcuInterfaceToProcess.WaitTankStopFinished();
        MD_DeskOrder   : IF PaintRobot[elem.kin.kinListInx].chgMaskingDevice THEN
                            CASE Job OF
                               ON  : WAIT (PaintRobot[elem.kin.kinListInx].fieldbusIn.MDDeskRelease.svBool = TRUE);
                               OFF : WAIT (PaintRobot[elem.kin.kinListInx].fieldbusIn.MDDeskRelease.svBool = FALSE);
                            END_CASE;
                         END_IF;
        MD_Cover       : CASE Job OF
                            ON  : WAIT (elem.kin.RcuInterfaceToProcess.svCoverIni = TRUE);
                            OFF : WAIT (elem.kin.RcuInterfaceToProcess.svCoverIni = FALSE);
                         END_CASE;
        MD_Coupling    : CASE Job OF
                            ON  : WAIT (elem.kin.RcuInterfaceToProcess.svCouplingIni = TRUE);
                            OFF : WAIT (elem.kin.RcuInterfaceToProcess.svCouplingIni = FALSE);
                         END_CASE;
        MD_MaskGripper : IF PaintRobot[elem.kin.kinListInx].chgMaskingDevice THEN
                            CASE Job OF
                               ON  : WAIT (PaintRobot[elem.kin.kinListInx].fieldbusIn.MDGripperOpen.svBool = TRUE);
                               OFF : WAIT (PaintRobot[elem.kin.kinListInx].fieldbusIn.MDGripperOpen.svBool = FALSE);
                            END_CASE;
                         END_IF;
        PivotingBracketInPos : WAIT (elem.kin.RcuInterfaceToProcess.svPivotingBracketInPos = TRUE);
     ELSE
        RcuSetMessageOnce(EcoTalk_ErrUnknownGroup, elem.kin.kinListInx, 6, 0, "Ecotalk.WAIT_PROCESS_STATE", STR(iLine), STR(Group), "WAIT_PROCESS_STATE");
        elem.kin.ErrorReaction(TRUE);
        RETURN FALSE;
     END_CASE;
  END_IF;
  RETURN FALSE;
  
END_ROUTINE


ROUTINE SET_BOOL_SYSTEMVAR(functionUnit : TRcuFunctionUnit; varname : STRING; state : IOTYPE; resetAtProgEnd : TRcuResetAtProgEnd) GLOBAL USER { macro="OTHER" }
 VAR
  sSvName  : STRING;
  elem     : TRcuKinListElem; // element with the kinematicreference
  varRef   : TInOutBool;
  iLine    : DINT;
  info     : TUserProgStackInfo;
  varState : BOOL;
  varReset : BOOL;
 END_VAR;
 
  IF RcData.CheckKin(elem, "SET_BOOL_SYSTEMVAR") THEN
     CASE functionUnit OF
       PCUx:       sSvName := "PCU" + STR(gyiNrPcu[elem.kin.kinListInx]) + "." + varname;
       RCUx:       sSvName := "RCU" + STR(gyiNrRcu[elem.kin.kinListInx]) + "." + varname;
       BCUx:       sSvName := "BCU" + STR(gyiNrBcu[elem.kin.kinListInx]) + "." + varname;
       FUsystem:   sSvName := "system." + varname;
     END_CASE;
     varRef.svBool := MAPX(sSvName);
     IF IS_MAPPED(varRef.svBool) THEN
        CASE state OF
           High : varState := TRUE;
           Low  : varState := FALSE;
        ELSE
           STOPPOINT();
           RcuSetMessageOnce(EcoTalk_ErrInvalidValue, elem.kin.kinListInx, 15, 0, "Ecotalk.SET_BOOL_SYSTEMVAR", "state = Data");
           elem.kin.ErrorReaction(TRUE);
           RETURN;
        END_CASE;
        CASE resetAtProgEnd OF
           ResetAtProgEnd   : varReset := TRUE;
           NoResetAtProgEnd : varReset := FALSE;
        END_CASE;
        START SetBool_Systemvar(sSvName, varRef, varState, varReset);
     ELSE 
        STOPPOINT(); 
        //Get Line of Teachprog for Error-Msg
        IF GetUserProgCallStackInfo(0, info) THEN
           IF info.depth > 0 THEN
              iLine := info.lineNrs[info.depth-1]; 
           ELSE
              iLine := info.lineNrs[0]; 
           END_IF;
        END_IF;
        RcuSetMessageOnce(EcoTalk_ErrMapSysVar, elem.kin.kinListInx, 1, 0, "Ecotalk.SET_BOOL_SYSTEMVAR", sSvName, "SET_BOOL_SYSTEMVAR", STR(iLine));
        elem.kin.ErrorReaction(TRUE);
        RETURN;
     END_IF;
  END_IF;
END_ROUTINE

ROUTINE SetBool_Systemvar(name : STRING; boolvar : TInOutBool; state : BOOL; reset : BOOL) PRIVATE
 VAR
  i        : SINT;
  elem     : TRcuKinListElem; // element with the kinematicreference
  found    : BOOL;
  sLogText : STRING;
 END_VAR;

   IF RcData.CheckKin(elem, "SET_BOOL_SYSTEMVAR") THEN
      // variable should be reset at RELEASE of kinematic --> store name in "Reset List"
      IF reset THEN
         i     := 0;
         found := FALSE;
         WHILE (i < cgiSizeEcoTalkVarList) AND NOT found DO
             IF (elem.kin.ecoTalkVarListBool.ySysVarNameReset[i] = name) THEN
                found := TRUE;
             ELSE
                i := i + 1;
             END_IF; 
         END_WHILE;
         IF NOT found THEN
            i     := 0;
            found := FALSE;
            //find next free array field
            WHILE (i < cgiSizeEcoTalkVarList) AND NOT found DO
                IF (elem.kin.ecoTalkVarListBool.ySysVarNameReset[i] = "") THEN
                   elem.kin.ecoTalkVarListBool.ySysVarNameReset[i] := name;
                   found := TRUE;
                ELSE
                   i := i + 1;
                END_IF; 
            END_WHILE;
            IF (NOT found) THEN 
               MAINRUN();
               RcuSetMessageOnce(EcoTalk_ErrTooMuchSysVar, elem.kin.kinListInx, 1, 0, "Ecotalk.SetBool_Systemvar", STR(cgiSizeEcoTalkVarList));
            END_IF;
         END_IF;
      // at end of GhostNoMotion, all variables should be reset --> store name in "No-Reset List"
      ELSIF elem.kin.allDrivesSimulated THEN
         i     := 0;
         found := FALSE;
         WHILE (i < cgiSizeEcoTalkVarList) AND NOT found DO
             IF (elem.kin.ecoTalkVarListBool.ySysVarNameNoReset[i] = name) THEN
                found := TRUE;
             ELSE
                i := i + 1;
             END_IF; 
         END_WHILE;
         IF NOT found THEN
            i     := 0;
            found := FALSE;
            //find next free array field
            WHILE (i < cgiSizeEcoTalkVarList) AND NOT found DO
                IF (elem.kin.ecoTalkVarListBool.ySysVarNameNoReset[i] = "") THEN
                   elem.kin.ecoTalkVarListBool.ySysVarNameNoReset[i] := name;
                   found := TRUE;
                ELSE
                   i := i + 1;
                END_IF; 
            END_WHILE;
            IF (NOT found) THEN 
               MAINRUN();
               RcuSetMessageOnce(EcoTalk_ErrTooMuchSysVar, elem.kin.kinListInx, 2, 0, "Ecotalk.SetBool_Systemvar", STR(cgiSizeEcoTalkVarList));
            END_IF;
         END_IF;
      END_IF;
      MAINRUN();
      IF IS_MAPPED(boolvar.svBool) THEN
         IF (boolvar.svBool <> state) THEN
             sLogText := "SET_BOOL_SYSTEMVAR - " + name + "=" + STR(state) + " reset=" + STR(reset);
             elem.kin.logger.SetLoggerStep(elem.kin.autoControl.iLoggerNumber, sLogText);
         END_IF;          
         boolvar.svBool := state;
         PRINT("SET_BOOL_SYSTEMVAR : variable " + name + " gets value : " + STR(boolvar.svBool));
      ELSE
         RcuSetMessageOnce(EcoTalk_ErrMapSysVar, elem.kin.kinListInx, 2, 0, "Ecotalk.SetBool_Systemvar", name, "SetBool_Systemvar", "-");
         elem.kin.ErrorReaction(TRUE);
      END_IF;   
   END_IF;
END_ROUTINE

ROUTINE GET_BOOL_SYSTEMVAR(functionUnit : TRcuFunctionUnit; varname : STRING; state : IOTYPE) : BOOL GLOBAL USER { macro="OTHER" }
 VAR
  sSvName  : STRING;
  elem     : TRcuKinListElem; // element with the kinematicreference
  varRef   : TInOutBool;
  iLine    : DINT;
  info     : TUserProgStackInfo;
  varState : BOOL;
 END_VAR;
 
  IF RcData.CheckKin(elem, "GET_BOOL_SYSTEMVAR") THEN
     CASE functionUnit OF
       PCUx:       sSvName := "PCU" + STR(gyiNrPcu[elem.kin.kinListInx]) + "." + varname;
       RCUx:       sSvName := "RCU" + STR(gyiNrRcu[elem.kin.kinListInx]) + "." + varname;
       BCUx:       sSvName := "BCU" + STR(gyiNrBcu[elem.kin.kinListInx]) + "." + varname;
       FUsystem:   sSvName := "system." + varname;
     END_CASE;
     varRef.svBool := MAPX(sSvName);
     IF IS_MAPPED(varRef.svBool) THEN
        CASE state OF
           High : varState := TRUE;
           Low  : varState := FALSE;
        ELSE
           STOPPOINT();
           RcuSetMessageOnce(EcoTalk_ErrInvalidValue, elem.kin.kinListInx, 16, 0, "Ecotalk.GET_BOOL_SYSTEMVAR", "state = Data");
           elem.kin.ErrorReaction(TRUE);
           RETURN FALSE;
        END_CASE;
        IF NOT elem.kin.progPath.bAppendLate THEN  
           STOPPOINT();
        END_IF;
        PRINT("GET_BOOL_SYSTEMVAR : variable " + sSvName + " returns value : " + STR(varRef.svBool = varState));
        RETURN (varRef.svBool = varState);
     ELSE  
        STOPPOINT();
        //Get Line of Teachprog for Error-Msg
        IF GetUserProgCallStackInfo(0, info) THEN
           IF info.depth > 0 THEN
              iLine := info.lineNrs[info.depth-1]; 
           ELSE
              iLine := info.lineNrs[0]; 
           END_IF;
        END_IF;
        RcuSetMessageOnce(EcoTalk_ErrMapSysVar, elem.kin.kinListInx, 3, 0, "Ecotalk.GET_BOOL_SYSTEMVAR", sSvName, "GET_BOOL_SYSTEMVAR", STR(iLine));
        elem.kin.ErrorReaction(TRUE);
        RETURN FALSE;
     END_IF;
  END_IF;
  RETURN FALSE;
END_ROUTINE

ROUTINE WAIT_BOOL_SYSTEMVAR(functionUnit : TRcuFunctionUnit; varname : STRING; state : IOTYPE) GLOBAL USER { macro="OTHER" }
 VAR
  sSvName  : STRING;
  elem     : TRcuKinListElem; // element with the kinematicreference
  varRef   : TInOutBool;
  iLine    : DINT;
  info     : TUserProgStackInfo;
  varState : BOOL;
 END_VAR;
 
  IF RcData.CheckKin(elem, "WAIT_BOOL_SYSTEMVAR") THEN
     CASE functionUnit OF
       PCUx:       sSvName := "PCU" + STR(gyiNrPcu[elem.kin.kinListInx]) + "." + varname;
       RCUx:       sSvName := "RCU" + STR(gyiNrRcu[elem.kin.kinListInx]) + "." + varname;
       BCUx:       sSvName := "BCU" + STR(gyiNrBcu[elem.kin.kinListInx]) + "." + varname;
       FUsystem:   sSvName := "system." + varname;
     END_CASE;
     varRef.svBool := MAPX(sSvName);
     IF IS_MAPPED(varRef.svBool) THEN
        CASE state OF
           High : varState := TRUE;
           Low  : varState := FALSE;
        ELSE
           STOPPOINT();
           RcuSetMessageOnce(EcoTalk_ErrInvalidValue, elem.kin.kinListInx, 17, 0, "Ecotalk.WAIT_BOOL_SYSTEMVAR", "state = Data");
           elem.kin.ErrorReaction(TRUE);
           RETURN;
        END_CASE;
        STOPPOINT();
        PRINT("WAIT_BOOL_SYSTEMVAR is waiting for variable " + sSvName + " = " + STR(varState));
        WAIT (varRef.svBool = varState);
        RETURN;
     ELSE  
        STOPPOINT();
        //Get Line of Teachprog for Error-Msg
        IF GetUserProgCallStackInfo(0, info) THEN
           IF info.depth > 0 THEN
              iLine := info.lineNrs[info.depth-1]; 
           ELSE
              iLine := info.lineNrs[0]; 
           END_IF;
        END_IF;
        RcuSetMessageOnce(EcoTalk_ErrMapSysVar, elem.kin.kinListInx, 4, 0, "Ecotalk.WAIT_BOOL_SYSTEMVAR", sSvName, "WAIT_BOOL_SYSTEMVAR", STR(iLine));
        elem.kin.ErrorReaction(TRUE);
        RETURN;
     END_IF;
  END_IF;
END_ROUTINE


ROUTINE SET_INT_SYSTEMVAR(functionUnit : TRcuFunctionUnit; varName : STRING; value : INT; resetAtProgEnd : TRcuResetAtProgEnd) GLOBAL USER { macro="OTHER" }
   VAR
      sSvName  : STRING;
      elem     : TRcuKinListElem; // element with the kinematicreference
      varRef   : TInOutWord;
      iLine    : DINT;
      info     : TUserProgStackInfo;
      varReset : BOOL;
   END_VAR;
   
   IF RcData.CheckKin(elem, "SET_INT_SYSTEMVAR") THEN
      
      //Get Line of Teachprog for Error-Msg
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
            iLine := info.lineNrs[info.depth-1]; 
         ELSE
            iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      CASE functionUnit OF
         PCUx:       sSvName := "PCU" + STR(gyiNrPcu[elem.kin.kinListInx]) + "." + varName;
         RCUx:       sSvName := "RCU" + STR(gyiNrRcu[elem.kin.kinListInx]) + "." + varName;
         BCUx:       sSvName := "BCU" + STR(gyiNrBcu[elem.kin.kinListInx]) + "." + varName;
         FUsystem:   sSvName := "system." + varName;
      END_CASE;
      
      varRef.svWord := MAPX(sSvName);
      
      IF IS_MAPPED(varRef.svWord) THEN
         CASE resetAtProgEnd OF
            ResetAtProgEnd   : varReset := TRUE;
            NoResetAtProgEnd : varReset := FALSE;
         END_CASE;
         START SetInt_Systemvar(sSvName, varRef, value, varReset);
      ELSE 
         STOPPOINT();
         RcuSetMessageOnce(EcoTalk_ErrMapSysVar, elem.kin.kinListInx, 5, 0, "Ecotalk.SET_INT_SYSTEMVAR", sSvName, "SET_INT_SYSTEMVAR", STR(iLine));
         elem.kin.ErrorReaction(TRUE);
         RETURN;
      END_IF;
      
   END_IF;
   
END_ROUTINE

ROUTINE SetInt_Systemvar(name : STRING; intVar : TInOutWord; value : INT; reset : BOOL) PRIVATE
   VAR
      i        : SINT;
      elem     : TRcuKinListElem; // element with the kinematicreference
      found    : BOOL;
      sLogText : STRING;
   END_VAR;
   
   IF RcData.CheckKin(elem, "SET_INT_SYSTEMVAR") THEN
      
      // variable should be reset at RELEASE of kinematic --> store name in "Reset List"
      IF reset THEN
         i     := 0;
         found := FALSE;
         
         WHILE (i < cgiSizeEcoTalkVarList) AND NOT found DO
            IF (elem.kin.ecoTalkVarListInt.ySysVarNameReset[i] = name) THEN
               found := TRUE;
            ELSE
               i := i + 1;
            END_IF; 
         END_WHILE;
         
         IF NOT found THEN
            i     := 0;
            found := FALSE;
            //find next free array field
            WHILE (i < cgiSizeEcoTalkVarList) AND NOT found DO
               IF (elem.kin.ecoTalkVarListInt.ySysVarNameReset[i] = "") THEN
                  elem.kin.ecoTalkVarListInt.ySysVarNameReset[i] := name;
                  found := TRUE;
               ELSE
                  i := i + 1;
               END_IF; 
            END_WHILE;
            IF (NOT found) THEN 
               MAINRUN();
               RcuSetMessageOnce(EcoTalk_ErrTooMuchSysVar, elem.kin.kinListInx, 3, 0, "Ecotalk.SetInt_Systemvar", STR(cgiSizeEcoTalkVarList));
            END_IF;
         END_IF;
         
      // at end of GhostNoMotion, all variables should be reset --> store name in "No-Reset List"
      ELSIF elem.kin.allDrivesSimulated THEN
         i     := 0;
         found := FALSE;
         
         WHILE (i < cgiSizeEcoTalkVarList) AND NOT found DO
            IF (elem.kin.ecoTalkVarListInt.ySysVarNameNoReset[i] = name) THEN
               found := TRUE;
            ELSE
               i := i + 1;
            END_IF; 
         END_WHILE;
         
         IF NOT found THEN
            i     := 0;
            found := FALSE;
            //find next free array field
            WHILE (i < cgiSizeEcoTalkVarList) AND NOT found DO
               IF (elem.kin.ecoTalkVarListInt.ySysVarNameNoReset[i] = "") THEN
                  elem.kin.ecoTalkVarListInt.ySysVarNameNoReset[i] := name;
                  found := TRUE;
               ELSE
                  i := i + 1;
               END_IF; 
            END_WHILE;
            IF (NOT found) THEN 
               MAINRUN();
               RcuSetMessageOnce(EcoTalk_ErrTooMuchSysVar, elem.kin.kinListInx, 4, 0, "Ecotalk.SetInt_Systemvar", STR(cgiSizeEcoTalkVarList));
            END_IF;
         END_IF;
         
      END_IF;
      
      MAINRUN();
      
      IF IS_MAPPED(intVar.svWord) THEN
         IF (intVar.svWord <> value) THEN
            sLogText := "SET_INT_SYSTEMVAR - " + name + "=" + STR(value) + " reset=" + STR(reset);
            elem.kin.logger.SetLoggerStep(elem.kin.autoControl.iLoggerNumber, sLogText);
         END_IF;          
         intVar.svWord := value;
         PRINT("SET_INT_SYSTEMVAR : variable " + name + " gets value : " + STR(intVar.svWord));
      ELSE
         RcuSetMessageOnce(EcoTalk_ErrMapSysVar, elem.kin.kinListInx, 6, 0, "Ecotalk.SetInt_Systemvar", name, "SetInt_Systemvar", "-");
         elem.kin.ErrorReaction(TRUE);
      END_IF;
      
   END_IF;
   
END_ROUTINE


ROUTINE GET_INT_SYSTEMVAR(functionUnit : TRcuFunctionUnit; varName : STRING) : INT GLOBAL USER { macro="OTHER" }
   VAR
      sSvName  : STRING;
      elem     : TRcuKinListElem; // element with the kinematicreference
      varRef   : TInOutWord;
      iLine    : DINT;
      info     : TUserProgStackInfo;
   END_VAR;
   
   IF RcData.CheckKin(elem, "GET_INT_SYSTEMVAR") THEN
      
      //Get Line of Teachprog for Error-Msg
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
            iLine := info.lineNrs[info.depth-1]; 
         ELSE
            iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      CASE functionUnit OF
         PCUx:       sSvName := "PCU" + STR(gyiNrPcu[elem.kin.kinListInx]) + "." + varName;
         RCUx:       sSvName := "RCU" + STR(gyiNrRcu[elem.kin.kinListInx]) + "." + varName;
         BCUx:       sSvName := "BCU" + STR(gyiNrBcu[elem.kin.kinListInx]) + "." + varName;
         FUsystem:   sSvName := "system." + varName;
      END_CASE;
      
      varRef.svWord := MAPX(sSvName);
      
      IF IS_MAPPED(varRef.svWord) THEN
         IF NOT elem.kin.progPath.bAppendLate THEN  
            STOPPOINT();
         END_IF;
         PRINT("GET_INT_SYSTEMVAR : variable " + sSvName + " returns value : " + STR(varRef.svWord));
         RETURN varRef.svWord;
      ELSE  
         STOPPOINT();
         RcuSetMessageOnce(EcoTalk_ErrMapSysVar, elem.kin.kinListInx, 7, 0, "Ecotalk.GET_INT_SYSTEMVAR", sSvName, "GET_INT_SYSTEMVAR", STR(iLine));
         elem.kin.ErrorReaction(TRUE);
         RETURN 0;
      END_IF;
      
   END_IF;
   RETURN 0;
   
END_ROUTINE


ROUTINE WAIT_INT_SYSTEMVAR(functionUnit : TRcuFunctionUnit; varName : STRING; value : INT) GLOBAL USER { macro="OTHER" }
   VAR
      sSvName  : STRING;
      elem     : TRcuKinListElem; // element with the kinematicreference
      varRef   : TInOutWord;
      iLine    : DINT;
      info     : TUserProgStackInfo;
   END_VAR;
   
   IF RcData.CheckKin(elem, "WAIT_INT_SYSTEMVAR") THEN
      
      //Get Line of Teachprog for Error-Msg
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
            iLine := info.lineNrs[info.depth-1]; 
         ELSE
            iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      CASE functionUnit OF
         PCUx:       sSvName := "PCU" + STR(gyiNrPcu[elem.kin.kinListInx]) + "." + varName;
         RCUx:       sSvName := "RCU" + STR(gyiNrRcu[elem.kin.kinListInx]) + "." + varName;
         BCUx:       sSvName := "BCU" + STR(gyiNrBcu[elem.kin.kinListInx]) + "." + varName;
         FUsystem:   sSvName := "system." + varName;
      END_CASE;
      
      varRef.svWord := MAPX(sSvName);
      
      IF IS_MAPPED(varRef.svWord) THEN
         STOPPOINT();
         PRINT("WAIT_INT_SYSTEMVAR is waiting for variable " + sSvName + " = " + STR(value));
         WAIT (varRef.svWord = value);
         RETURN;
      ELSE  
         STOPPOINT();
         RcuSetMessageOnce(EcoTalk_ErrMapSysVar, elem.kin.kinListInx, 8, 0, "Ecotalk.WAIT_INT_SYSTEMVAR", sSvName, "WAIT_INT_SYSTEMVAR", STR(iLine));
         elem.kin.ErrorReaction(TRUE);
         RETURN;
      END_IF;
   END_IF;
END_ROUTINE


// --------------------- E C O T A L K -----------------------------------------
// 28-02-2004 Bauder
// delay for t seconds
(*ROUTINE DELAY(t : INT) GLOBAL USER
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
      dTime : DINT;
   END_VAR

   IF t > 0 THEN
      IF RcData.CheckKin(elem, "DELAY") THEN  // wait on the path for a given period of time    
         //elem.kin.StartMovement();
         elem.kin.progPath.WaitSecs(t);
      ELSE
         dTime := t;
         dTime := dTime*1000;
         WAIT MAIN_RUN;
         Sleep(dTime);
      END_IF;
   END_IF;
END_ROUTINE
*)


ROUTINE DELAY(t : REAL) GLOBAL USER { macro="OTHER" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
      dTime : DINT;
   END_VAR

   IF t > 0 THEN
      IF RcData.CheckKin(elem, "DELAY") THEN  // wait on the path for a given period of time    
         IF elem.kin.homing.SimulateMacro("DELAY") THEN
            RETURN;
         END_IF;
         elem.kin.progPath.WaitSecs(t);
      ELSE
         dTime := t*1000;
         //WAIT MAIN_RUN;
         STOPPOINT();
         Sleep(dTime);
      END_IF;
   END_IF;
END_ROUTINE


//-----------------------------------------------------------------------------
// Print given text to telnet with kinematic-index
//-----------------------------------------------------------------------------
ROUTINE PRINTSTR(s : STRING) GLOBAL USER { macro="OTHER" }
  VAR
    elem : TRcuKinListElem; // element with the kinematicreference
  END_VAR
   
  IF RcData.CheckKin(elem, "PRINTSTR") THEN
     PRINT("Kin " + STR(elem.kin.kinListInx) + " " + s);
  END_IF;

END_ROUTINE


ROUTINE MAINRUN() GLOBAL USER { macro="OTHER" }
   WAIT MAIN_RUN;
END_ROUTINE


// setting last-stop variable to avoid repos
// use this instead of MAINRUN whenever waiting for mainrun within the main-flow
// MAINRUN should be used when mainrun-position is needed from within a Co-Routine
ROUTINE STOPPOINT() GLOBAL
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR

   IF RcData.CheckKin(elem, "STOPPOINT") THEN
      elem.kin.progPath.TransferBufferToPathWithCheck(elem.kin.iActMotionBuffer);
      elem.kin.progPath.SetStopPoint();
   END_IF;
   WAIT MAIN_RUN;
END_ROUTINE


ROUTINE TCP_SPEED_CHECK(OnOff : BOOL; Limit : REAL) GLOBAL USER { macro="OTHER" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR

   IF RcData.CheckKin(elem, "TCP_SPEED_CHECK") THEN
      elem.kin.RcuInterfaceToProcess.TcpSpeedCheck(OnOff, Limit);
   END_IF;
END_ROUTINE


// stop ecotalk programm until start key is pressed again, useful for testing subprogramms
ROUTINE STOP_IN_TEACHMODE() GLOBAL USER { macro="OTHER" }
  VAR
     elem : TRcuKinListElem; // element with the kinematicreference
  END_VAR

   IF RcData.CheckKin(elem, "STOP_IN_TEACHMODE") THEN
      IF (elem.kin.mainModeMgr.mode = ciT1) OR (elem.kin.mainModeMgr.mode = ciT2) THEN
         STOPPOINT();
         IF (elem.kin.selectingFlow.flowId > 0) THEN
            InterruptProg(elem.kin.selectingFlow.flowId);
         ELSE
            RcuSetMessageOnce(EcoTalk_ErrInvalidValue, elem.kin.kinListInx, 14, 0, "Ecotalk.STOP_IN_TEACHMODE", "selectingFlow.flowId");
            elem.kin.ErrorReaction(TRUE);
         END_IF;
      END_IF;   
   END_IF;
   
END_ROUTINE

ROUTINE HOMING(s : STRING) : BOOL GLOBAL USER { macro="OTHER"| enable="_system.gRcuFocusedRobot.homing.bEnableHoming" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
      dTime : DINT;
   END_VAR

   IF RcData.CheckKin(elem, "HOMING") THEN     
      IF NOT elem.kin.homing.bEnableHoming THEN
         elem.kin.DebugPrint(eTraceAutoControl, "Makro 'HOMING' ignoriert"); // Warnung
         RETURN FALSE;
      END_IF;
      elem.kin.DebugPrint(eTraceAutoControl, "HOMING Vergleich von "+s+" mit "+elem.kin.homing.sModuleName);
      RETURN StrToLower(s) = StrToLower(elem.kin.homing.sModuleName);
   END_IF;
   RETURN FALSE;
END_ROUTINE


(******************************************************************************************************************
******************   Group  Timer in Teachview - menu    **********************************************************
******************************************************************************************************************)


ROUTINE TIMERSTART() GLOBAL USER { macro="Timer" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR

   IF RcData.CheckKin(elem, "TIMERSTART") THEN
      START elem.kin.autoControl.MainRunTimerStart();
   END_IF;
END_ROUTINE


ROUTINE TIMERSTOP(t : DINT) GLOBAL USER { macro="Timer" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR

   IF RcData.CheckKin(elem, "TIMERSTOP") THEN
      START elem.kin.autoControl.MainRunTimerStop(t);
   END_IF;
END_ROUTINE


ROUTINE DATA_RECORDING(activate : DATARECORDINGCMD; signalset : INT ) GLOBAL USER { macro="OTHER" }
   VAR
      elem              : TRcuKinListElem; // element with the kinematicreference
      timeOut           : BOOL;
      timeOutDeactivate : BOOL;
   END_VAR
   
   IF RcData.CheckKin(elem, "DATA_RECORDING") THEN
     STOPPOINT();
     IF (activate = REC_ON) THEN
       mDataRecordingRequestedSignalset := signalset;
       mActivateDataRecording := TRUE;
       Sleep(1000);
     ELSE
       mDataRecordingRequestedSignalset := 0;
       Sleep(500);
       mActivateDataRecording := FALSE;
     END_IF; 
     
     SysTimerSet(5000, timeOut); 
     IF (activate = REC_ON) THEN
       WAIT mDataRecordingActive OR timeOut;
       DebugPrint(eTraceCommon, "swo starten: mDataRecordingActive=" + STR(mDataRecordingActive) + ", timeOut=" + STR(timeOut));
     ELSE
       WAIT NOT mDataRecordingActive OR timeOut;
       DebugPrint(eTraceCommon, "swo stoppen: mDataRecordingActive=" + STR(mDataRecordingActive) + ", timeOut=" + STR(timeOut));
     END_IF;
   END_IF;
   
END_ROUTINE


ROUTINE SET_STIFFNESS() : BOOL GLOBAL USER { macro="OTHER" }
   VAR
      elem   : TRcuKinListElem; // element with the kinematicreference
      chgCmd : BOOL;
   END_VAR
   
   IF RcData.CheckKin(elem, "SET_STIFFNESS") THEN
      STOPPOINT();
      giDRCommand := 0;
      giResponseDRCommand := 0;
      chgCmd := IS_CHANGED(giDRCommand);
      PaintRobot[elem.kin.kinListInx].stiffnessMacroHdl := GetProgHdl();
      gbReadyForDRCommand := TRUE;
      
      // giDRCommand:
      // 1 = Set New Stiffness, 2 = Abort, 3 = Continue, 0 = Reset Interface
      REPEAT
         WAIT chgCmd;
         chgCmd := FALSE;
         IF giDRCommand = 1 THEN
            PaintRobot[elem.kin.kinListInx].setNewStiffness := 2;
            WAIT PaintRobot[elem.kin.kinListInx].setNewStiffness <> 2;
            IF PaintRobot[elem.kin.kinListInx].setNewStiffness = 1 THEN
               giResponseDRCommand := 1;
            ELSE
               giResponseDRCommand := -1;
            END_IF;
         ELSIF giDRCommand = 2 THEN
            giResponseDRCommand := 2;
         ELSIF giDRCommand = 3 THEN
            giResponseDRCommand := 3;
         ELSIF giDRCommand = 0 THEN
            giResponseDRCommand := 0;
         END_IF;
      UNTIL (giDRCommand = 2) OR (giDRCommand = 3);
      gbReadyForDRCommand := FALSE;
      
      IF giDRCommand = 2 THEN
         RETURN FALSE;
      ELSIF giDRCommand = 3 THEN
         RETURN TRUE;
      ELSE
         // just for compiler
         RETURN FALSE;
      END_IF;
   ELSE
      // just for compiler
      RETURN FALSE;
   END_IF;
END_ROUTINE


ROUTINE SET_PLC_ORDER(Step : PLCORDER; Run : TRcuPreMainRun) GLOBAL USER { macro="OTHER" | enable="_system.gRcuFocusedRobot.bEnablePlcOrderByte" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
      s    : STRING;
      iLine   : DINT;
      info    : TUserProgStackInfo;
   END_VAR
   
   IF RcData.CheckKin(elem, "SET_PLC_ORDER") THEN
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
          iLine := info.lineNrs[info.depth-1]; 
         ELSE
          iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      IF PaintRobot[elem.kin.kinListInx].bEnablePlcOrderByte THEN
         WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.PlcOrder.svByte = 0;
         DebugPrint(eTraceGluing, elem.kin.robotName + "-EcoTalk: Execute SET_PLC_ORDER - PLCORDER: " + STR(Step) + " with " + Enum2String_Run(Run));
         CASE Run OF
            MainRun   : START SetPlcOrder(Step, Run);    
                   
            PreRun    : SetPlcOrder(Step, Run);
                      
            Stopp     : STOPPOINT();
                        SetPlcOrder(Step, Run);
         ELSE 
            RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 12, 0, "Ecotalk.SET_PLC_ORDER",  STR(iLine), "TRcuPreMainRun", STR(Run));
            elem.kin.ErrorReaction(TRUE);  
         END_CASE;
                      
      ELSE
        // todo error: no gluing robot
      END_IF;
    END_IF; 
                            
END_ROUTINE
                            
           
ROUTINE SetPlcOrder(Step : PLCORDER; Run : TRcuPreMainRun) PRIVATE
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "SetPlcOrder") THEN
     IF Run = MainRun THEN
        MAINRUN();
      END_IF;
     PaintRobot[elem.kin.kinListInx].fieldbusOut.PlcOrder.svByte := Step;
   END_IF;
   
END_ROUTINE


ROUTINE Enum2String_Run(Run : TRcuPreMainRun) : STRING PRIVATE
   CASE Run OF
      MainRun   : RETURN "MainRun";   

      PreRun    : RETURN "PreRun";

      Stopp     : RETURN "Stopp";
   ELSE
      RETURN "Undefined runtype";
   END_CASE;
END_ROUTINE


ROUTINE RECEIVE_PLC_STATE(Step : PLCORDER; Run : TRcuPreMainRun) : DINT GLOBAL USER { macro="OTHER" | enable="_system.gRcuFocusedRobot.bEnablePlcOrderByte" }        
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "RECEIVE_PLC_STATE") THEN
      IF PaintRobot[elem.kin.kinListInx].bEnablePlcOrderByte THEN
         DebugPrint(eTraceGluing, elem.kin.robotName + "-EcoTalk: Execute RECEIVE_PLC_STATE - PLCORDER: " + STR(Step) + " with " + Enum2String_Run(Run));
         IF (Run = MainRun) OR (Run = Stopp) THEN
            STOPPOINT();
         END_IF;
         WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.PlcOrder.svByte = Step;
         PaintRobot[elem.kin.kinListInx].fieldbusOut.PlcOrder.svByte := 0; 
         RETURN INT(PaintRobot[elem.kin.kinListInx].fieldbusIn.PlcState.svByte);
         ELSE
        // todo error: no gluing robot
      END_IF;
   END_IF;
  RETURN 0;
END_ROUTINE


ROUTINE SET_PROCESS_ORDER(Step : ProcessOrder; Run : TRcuPreMainRun) GLOBAL USER { macro="PROCESS" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
      s    : STRING;     
      iLine   : DINT;
      info    : TUserProgStackInfo;
   END_VAR
   
   IF RcData.CheckKin(elem, "SET_PROCESS_ORDER") THEN
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
          iLine := info.lineNrs[info.depth-1]; 
         ELSE
          iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
       WAIT (elem.kin.RcuInterfaceToProcess.svProcessCmd = 0) AND 
            (elem.kin.RcuInterfaceToProcess.svProcessCmdAck = 0);

       DebugPrint(eTraceProcess, elem.kin.robotName + "-EcoTalk: Execute SET_PROCESS_ORDER - COMMAND: " + STR(Step) + " with " + Enum2String_Run(Run));

       CASE Run OF
          MainRun   : START SetProcessOrder(Step, Run);    

          PreRun    : SetProcessOrder(Step, Run);

          Stopp     : STOPPOINT();
                      SetProcessOrder(Step, Run);
       ELSE
         RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 13, 0, "Ecotalk.SET_PLC_ORDER",  STR(iLine), "TRcuPreMainRun", STR(Run));
         elem.kin.ErrorReaction(TRUE);
       END_CASE;
                      
    END_IF; 
                            
END_ROUTINE
                            
           
ROUTINE SetProcessOrder(Step : ProcessOrder; Run : TRcuPreMainRun) PRIVATE
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "SetProcessOrder") THEN
     IF Run = MainRun THEN
        MAINRUN();
     END_IF;
     elem.kin.RcuInterfaceToProcess.svProcessCmd := Step;
     
   END_IF;
END_ROUTINE


ROUTINE RECEIVE_PROCESS_STATE(Step : ProcessOrder; Run : TRcuPreMainRun) : DINT GLOBAL USER { macro="PROCESS" }        
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "RECEIVE_PROCESS_STATE") THEN
     DebugPrint(eTraceProcess, elem.kin.robotName + "-EcoTalk: Execute RECEIVE_PROCESS_STATE - COMMAND: " + STR(Step) + " with " + Enum2String_Run(Run));

     IF (Run = MainRun) OR (Run = Stopp) THEN
        STOPPOINT();
     END_IF;

     WAIT elem.kin.RcuInterfaceToProcess.svProcessCmdAck = Step;

     elem.kin.RcuInterfaceToProcess.svProcessCmd := 0; 
     
     RETURN INT(elem.kin.RcuInterfaceToProcess.svProcessState);

   END_IF;
   
   RETURN 0;
END_ROUTINE


//-----------------------------------------------------------------------------
// Send a command to IEC to move the applicator 
//-----------------------------------------------------------------------------
ROUTINE SET_APPLICATOR_POSITION(Position : APP_POS) GLOBAL USER { macro="GLUING" | enable="_system.gRcuFocusedRobot.gluingRobot" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
    
   IF RcData.CheckKin(elem, "SET_APPLICATOR_POSITION") THEN
      STOPPOINT();
      START elem.kin.RcuInterfaceToProcess.SetApplicator_Position(Position);
   END_IF;
END_ROUTINE


//-----------------------------------------------------------------------------
// Check the applicator position
//-----------------------------------------------------------------------------
ROUTINE WAIT_APPLICATOR_IN_POSITION(Position : APP_POS)  GLOBAL USER { macro="GLUING" | enable="_system.gRcuFocusedRobot.gluingRobot" }
   VAR
      elem    : TRcuKinListElem; // element with the kinematicreference
   END_VAR

   IF RcData.CheckKin(elem, "GET_APPLICATOR_POSITION") THEN     
      elem.kin.RcuInterfaceToProcess.Wait_Applicator_In_Position(Position);
   END_IF;
   
END_ROUTINE


ROUTINE IS_IN_FIXPOS(Fixpos : POINT) : BOOL GLOBAL USER { macro="OTHER" }    
    VAR
      elem         : TRcuKinListElem; // element with the kinematicreference
      iFixposIdx   : DINT;
      i            : DINT;
      bFound       : BOOL;
      FixposNr : DINT;
      iLine   : DINT;
      info    : TUserProgStackInfo;
   END_VAR

   bFound := FALSE;
   
   IF RcData.CheckKin(elem, "IS_IN_FIXPOS") THEN     
     IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
          iLine := info.lineNrs[info.depth-1]; 
         ELSE
          iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      STOPPOINT();
      // Find point in the available fixpositions
      FOR i:=0 TO cMaxFixpos-1 DO
         IF (PaintRobot[elem.kin.kinListInx].fixpos.yRcuFixpositions[i].sPointName = StrToLower(Fixpos.GetName())) THEN
            bFound := TRUE;
            iFixposIdx := i;
         END_IF;
      END_FOR;
      
      IF NOT bFound THEN
         STOPPOINT();
         // Point %1 is not a valid fixposition
         RcuSetMessageOnce(EcoTalk_ErrNotValidFixpos, elem.kin.kinListInx, 1, 0, "Ecotalk.IS_IN_FIXPOS",  STR(iLine), Fixpos.GetName());
         elem.kin.ErrorReaction(TRUE);
      END_IF;  
   END_IF;
   
   IF bFound AND PaintRobot[elem.kin.kinListInx].fixpos.yRcuInFixpositions[iFixposIdx] THEN
      RETURN TRUE;
   ELSE
      RETURN FALSE;
   END_IF;
      
END_ROUTINE


(******************************************************************************************************************
******************   Group  3D in Teachview - menu  ***************************************************************
******************************************************************************************************************)

ROUTINE CONFIG3D(Step1 : BOOL; PlaneStep1 : PLANE; Step2 : BOOL; PlaneStep2 : PLANE;
                 Step3 : BOOL; PlaneStep3 : PLANE) GLOBAL USER { macro="3D" | enable="_system.gRcuFocusedRobot.objMeasure.bBootUpOk" }
VAR
   elem : TRcuKinListElem; // element with the kinematicreference
END_VAR
   
   IF RcData.CheckKin(elem, "CONFIG3D") THEN
      STOPPOINT();
      IF NOT elem.kin.objMeasure.bBootUpOk THEN
         RcuResetMessage(EcoTalk_War3DMacroIgnored, elem.kin.kinListInx, 9, 0, "EcoTalk.CONFIG3D", "CONFIG3D");
         RETURN;
      END_IF;
      elem.kin.objMeasure.Config3D(Step1, PlaneStep1, Step2, PlaneStep2, Step3, PlaneStep3);
   END_IF;
   
END_ROUTINE


ROUTINE INIT3DOBJECT(P1 : POINT; P2 : POINT; P3 : POINT; P4 : POINT; P5 : POINT;
                     P6 : POINT; OBJ : OBJECT) GLOBAL USER { macro="3D" | enable="_system.gRcuFocusedRobot.objMeasure.bBootUpOk" }
VAR
   elem : TRcuKinListElem; // element with the kinematicreference
END_VAR
   
   IF RcData.CheckKin(elem, "INIT3DOBJECT") THEN
      STOPPOINT();
      IF NOT elem.kin.objMeasure.bBootUpOk THEN
         RcuResetMessage(EcoTalk_War3DMacroIgnored, elem.kin.kinListInx, 10, 0, "EcoTalk.INIT3DOBJECT", "INIT3DOBJECT");
         RETURN;
      END_IF;
      elem.kin.objMeasure.Init3DObject(P1, P2, P3, P4, P5, P6, OBJ);
   END_IF;
   
END_ROUTINE


ROUTINE CALC3DSTEP1(P1 : POINT; P2 : POINT; P3 : POINT; OBJ : OBJECT) : BOOL GLOBAL USER { macro="3D" | enable="_system.gRcuFocusedRobot.objMeasure.bBootUpOk"  }
VAR
   elem : TRcuKinListElem; // element with the kinematicreference
END_VAR
   
   IF RcData.CheckKin(elem, "CALC3DSTEP1") THEN
      STOPPOINT();
      IF NOT elem.kin.objMeasure.bBootUpOk THEN
         RcuResetMessage(EcoTalk_War3DMacroIgnored, elem.kin.kinListInx, 11, 0, "EcoTalk.CALC3DSTEP1", "CALC3DSTEP1");
         RETURN FALSE;
      END_IF;
      RETURN elem.kin.objMeasure.Calc3DStep1(P1, P2, P3, OBJ);
   END_IF;
   RETURN FALSE;
END_ROUTINE


ROUTINE CALC3DSTEP2(P4 : POINT; P5 : POINT; OBJ : OBJECT) : BOOL GLOBAL USER { macro="3D" | enable="_system.gRcuFocusedRobot.objMeasure.bBootUpOk" }
VAR
   elem : TRcuKinListElem; // element with the kinematicreference
END_VAR
   
   IF RcData.CheckKin(elem, "CALC3DSTEP2") THEN
      STOPPOINT();
      IF NOT elem.kin.objMeasure.bBootUpOk THEN
         RcuResetMessage(EcoTalk_War3DMacroIgnored, elem.kin.kinListInx, 12, 0, "EcoTalk.CALC3DSTEP2", "CALC3DSTEP2");
         RETURN FALSE;
      END_IF;
      RETURN elem.kin.objMeasure.Calc3DStep2(P4, P5, OBJ);
   END_IF;
   RETURN FALSE;
END_ROUTINE


ROUTINE CALC3DSTEP3(P6 : POINT; OBJ : OBJECT) : BOOL GLOBAL USER { macro="3D" | enable="_system.gRcuFocusedRobot.objMeasure.bBootUpOk" }
VAR
   elem : TRcuKinListElem; // element with the kinematicreference
END_VAR
   
   IF RcData.CheckKin(elem, "CALC3DSTEP3") THEN
      STOPPOINT();
      IF NOT elem.kin.objMeasure.bBootUpOk THEN
         RcuResetMessage(EcoTalk_War3DMacroIgnored, elem.kin.kinListInx, 13, 0, "EcoTalk.CALC3DSTEP3", "CALC3DSTEP3");
         RETURN FALSE;
      END_IF;
      RETURN elem.kin.objMeasure.Calc3DStep3(P6, OBJ);
   END_IF;
   RETURN FALSE;
END_ROUTINE


ROUTINE DEFINE3DOBJECT(PXMIN : POINT; PXMAX : POINT; PY : POINT; OBJ_REF : OBJECT) GLOBAL USER { macro="3D" | enable="_system.gRcuFocusedRobot.objMeasure.bBootUpOk" }
VAR
   elem : TRcuKinListElem; // element with the kinematicreference
END_VAR
   
   IF RcData.CheckKin(elem, "DEFINE3DOBJECT") THEN
      STOPPOINT();
      IF NOT elem.kin.objMeasure.bBootUpOk THEN
         RcuResetMessage(EcoTalk_War3DMacroIgnored, elem.kin.kinListInx, 14, 0, "EcoTalk.DEFINE3DOBJECT", "DEFINE3DOBJECT");
         RETURN;
      END_IF;
      elem.kin.objMeasure.Define3DObject(PXMIN, PXMAX, PY, OBJ_REF);
   END_IF;
   
END_ROUTINE


ROUTINE CALC3DTRAFO(OBJ_REF : OBJECT; OBJ_MEASURE : OBJECT; OBJ_ORG : OBJECT; OBJ_RESULT : OBJECT) GLOBAL USER { macro="3D" | enable="_system.gRcuFocusedRobot.objMeasure.bBootUpOk" }
VAR
   elem : TRcuKinListElem; // element with the kinematicreference
END_VAR
   
   IF RcData.CheckKin(elem, "CALC3DTRAFO") THEN
      STOPPOINT();
      IF NOT elem.kin.objMeasure.bBootUpOk THEN
         RcuResetMessage(EcoTalk_War3DMacroIgnored, elem.kin.kinListInx, 15, 0, "EcoTalk.CALC3DTRAFO", "CALC3DTRAFO");
         RETURN;
      END_IF;
      elem.kin.objMeasure.Calc3DTrafo(OBJ_REF, OBJ_MEASURE, OBJ_ORG, OBJ_RESULT);
   END_IF;
   
END_ROUTINE


// Wartet auf das Sensorsignal. Bei Erkennen des Sensorsignals wird 
// die Position gespeichert
ROUTINE RECEIVEPOS3D(P : POINT) : BOOL GLOBAL USER { macro="3D" | enable="_system.gRcuFocusedRobot.objMeasure.bBootUpOk" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR

   IF RcData.CheckKin(elem, "RECEIVEPOS3D") THEN
      IF NOT elem.kin.objMeasure.bBootUpOk THEN
         RcuResetMessage(EcoTalk_War3DMacroIgnored, elem.kin.kinListInx, 16, 0, "EcoTalk.RECEIVEPOS3D", "RECEIVEPOS3D");
         RETURN FALSE;
      END_IF;
      RETURN elem.kin.objMeasure.ReceivePos3D(P);
   END_IF;
   RETURN FALSE;
END_ROUTINE


// Ein-/Ausschalten des Lasers
ROUTINE SET_LASER(State : TRcuProcessJob) GLOBAL USER { macro="3D" | enable="_system.gRcuFocusedRobot.objMeasure.bBootUpOk" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR

   IF RcData.CheckKin(elem, "SET_LASER") THEN
      IF NOT elem.kin.objMeasure.bBootUpOk THEN
         RcuResetMessage(EcoTalk_War3DMacroIgnored, elem.kin.kinListInx, 17, 0, "EcoTalk.SET_LASER", "SET_LASER");
         RETURN;
      END_IF;
      STOPPOINT();
      START elem.kin.objMeasure.SetLaser(State);
   END_IF;
END_ROUTINE


(******************************************************************************************************************
******************   Group  BK in Teachview - menu  ***************************************************************
******************************************************************************************************************)

ROUTINE BK_INIT() GLOBAL USER { macro="BK" | enable="_system.gRcuFocusedRobot.vision.VisionBK.bBootUpOk" }
VAR
   elem : TRcuKinListElem; // element with the kinematicreference
END_VAR
   
   IF RcData.CheckKin(elem, "BK_INIT") THEN
      IF NOT elem.kin.vision.VisionBK.bBootUpOk THEN
         RcuResetMessage(EcoTalk_WarBKMacroIgnored, elem.kin.kinListInx, 8, 0, "EcoTalk.BK_INIT", "BK_INIT");
         RETURN;
      END_IF;
      IF elem.kin.vision.VisionBK.bGhostMode THEN
         RETURN; // ignore all BK macros in Ghostmode
      END_IF;
      STOPPOINT();
      elem.kin.vision.VisionBK.BK_Init();
   END_IF;
   
END_ROUTINE


ROUTINE BK_START(typeNr : DINT; pathID : DINT; mode : BK_MODE_TYPE) GLOBAL USER { macro="BK" | enable="_system.gRcuFocusedRobot.vision.VisionBK.bBootUpOk" }
VAR
   elem : TRcuKinListElem; // element with the kinematicreference
   itypeNr : INT;
   ipathID : INT;
END_VAR
   
   itypeNr := typeNr;
   ipathID := pathID;
   IF RcData.CheckKin(elem, "BK_START") THEN
      IF NOT elem.kin.vision.VisionBK.bBootUpOk THEN
         RcuResetMessage(EcoTalk_WarBKMacroIgnored, elem.kin.kinListInx, 9, 0, "EcoTalk.BK_START", "BK_START");
         RETURN;
      END_IF;
      IF elem.kin.vision.VisionBK.bGhostMode THEN
         RETURN; // ignore all BK macros in Ghostmode
      END_IF;
      STOPPOINT();
      elem.kin.vision.VisionBK.BK_Start(itypeNr, ipathID, mode);
   END_IF;
   
END_ROUTINE


ROUTINE BK_FINISH(numberOfPoint : DINT) : BOOL GLOBAL USER { macro="BK" | enable="_system.gRcuFocusedRobot.vision.VisionBK.bBootUpOk" } 
VAR
   elem : TRcuKinListElem; // element with the kinematicreference
   inumberOfPoint : INT;
END_VAR
   
   inumberOfPoint := numberOfPoint;
   IF RcData.CheckKin(elem, "BK_FINISH") THEN
      IF NOT elem.kin.vision.VisionBK.bBootUpOk THEN
         RcuResetMessage(EcoTalk_WarBKMacroIgnored, elem.kin.kinListInx, 10, 0, "EcoTalk.BK_FINISH", "BK_FINISH");
         RETURN TRUE;
      END_IF;
      IF elem.kin.vision.VisionBK.bGhostMode THEN
         RETURN TRUE; // ignore all BK macros in Ghostmode
      END_IF;
      STOPPOINT();
      RETURN elem.kin.vision.VisionBK.BK_Ende(inumberOfPoint);
   END_IF;
   RETURN FALSE;  
END_ROUTINE


ROUTINE BK_ACTION(point : POINT; pointNumber : DINT; trigger : TRIGGERFRAME) GLOBAL USER { macro="BK" | enable="_system.gRcuFocusedRobot.vision.VisionBK.bBootUpOk" } 
VAR
   elem : TRcuKinListElem; // element with the kinematicreference
   ipointNumber : INT;
END_VAR
   
   ipointNumber := pointNumber;
   IF RcData.CheckKin(elem, "BK_ACTION") THEN
      IF NOT elem.kin.vision.VisionBK.bBootUpOk THEN
         RcuResetMessage(EcoTalk_WarBKMacroIgnored, elem.kin.kinListInx, 11, 0, "EcoTalk.BK_ACTION", "BK_ACTION");
         RETURN;
      END_IF;
      IF elem.kin.vision.VisionBK.bGhostMode THEN
         RETURN; // ignore all BK macros in Ghostmode
      END_IF;
      trigger.TriggerBkAction(elem, point, ipointNumber);
   END_IF;
   
END_ROUTINE


ROUTINE BK_ACTION_DIRECT(pointNumber : DINT) GLOBAL USER { macro="BK" | enable="_system.gRcuFocusedRobot.vision.VisionBK.bBootUpOk" } 
VAR
   elem : TRcuKinListElem; // element with the kinematicreference
   ipointNumber : INT;
END_VAR
   
   ipointNumber := pointNumber;
   IF RcData.CheckKin(elem,"BK_ACTION_DIRECT") THEN
      IF NOT elem.kin.vision.VisionBK.bBootUpOk THEN
         RcuResetMessage(EcoTalk_WarBKMacroIgnored, elem.kin.kinListInx, 12, 0, "EcoTalk.BK_ACTION_DIRECT", "BK_ACTION_DIRECT");
         RETURN;
      END_IF;
      IF elem.kin.vision.VisionBK.bGhostMode THEN
         RETURN; // ignore all BK macros in Ghostmode
      END_IF;
      elem.kin.vision.VisionBK.TriggerDirectVmtBk(ipointNumber);
   END_IF;
   
END_ROUTINE


ROUTINE BK_CORR(pointNumber : DINT) GLOBAL USER { macro="BK" | enable="_system.gRcuFocusedRobot.vision.VisionBK.bBootUpOk" } 
VAR
   elem : TRcuKinListElem; // element with the kinematicreference
END_VAR
   
   IF RcData.CheckKin(elem, "BK_CORR") THEN
      IF NOT elem.kin.vision.VisionBK.bBootUpOk THEN
         RcuResetMessage(EcoTalk_WarBKMacroIgnored, elem.kin.kinListInx, 13, 0, "EcoTalk.BK_CORR", "BK_CORR");
         RETURN;
      END_IF;
      IF elem.kin.vision.VisionBK.bGhostMode THEN
         RETURN; // ignore all BK macros in Ghostmode
      END_IF;
      elem.kin.vision.VisionBK.BK_Korr(pointNumber);
   END_IF;
   
END_ROUTINE


(******************************************************************************************************************
******************   Group  MEASURE in Teachview - menu  **********************************************************
******************************************************************************************************************)

// Wartet auf das Sensorsignal. Bei Erkennen des Sensorsignals wird gemaess
// der gewhlten Richtung die entsprechende kartesische Koordinate gespeichert
ROUTINE RECEIVEVAL(ToolNr : TOOLID; currenttooltype : TOOLTYPE; worldmovingdirection : DIRECTION; 
                   tooldirection : DIRECTION) : BOOL GLOBAL USER { macro="MEASURE" | enable="_system.gRcuFocusedRobot.ToolMeasure.bConfigured"}
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR

   IF RcData.CheckKin(elem, "RECEIVEVAL") THEN
      IF NOT elem.kin.ToolMeasure.bConfigured THEN
         RcuResetMessage(EcoTalk_WarBKMacroIgnored, elem.kin.kinListInx, 13, 0, "EcoTalk.RECEIVEVAL", "RECEIVEVAL");
         RETURN FALSE;
      END_IF;
      RETURN elem.kin.ToolMeasure.ReceiveVal(ToolNr, currenttooltype, worldmovingdirection, tooldirection);
   END_IF;
   RETURN FALSE;
END_ROUTINE


// Das TOOL corrTool ergibt sich aus dem TOOL refTool durch Subtraktion der Differenzen
// von MESS_VAL und REF_VAL
ROUTINE SAVETOOL(ToolNr : TOOLID; currenttooltype : TOOLTYPE; refTool : TOOL; corrTool : TOOL) 
                 GLOBAL USER { macro="MEASURE" | enable="_system.gRcuFocusedRobot.ToolMeasure.bConfigured"}
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "SAVETOOL") THEN
      IF NOT elem.kin.ToolMeasure.bConfigured THEN
         RcuResetMessage(EcoTalk_WarBKMacroIgnored, elem.kin.kinListInx, 13, 0, "EcoTalk.SAVETOOL", "SAVETOOL");
         RETURN;
      END_IF;
      STOPPOINT();
      elem.kin.ToolMeasure.SaveTool(ToolNr, currenttooltype, refTool, corrTool);
   END_IF;
END_ROUTINE


// Das TOOL corrTool ergibt sich aus dem TOOL refTool durch Subtraktion der Differenzen
// von MESS_VAL und REF_VAL
ROUTINE SETTOLERANCE(ToolNr : TOOLID; XMinus : REAL; XPlus : REAL; YMinus : REAL; YPlus : REAL; ZMinus : REAL; ZPlus : REAL) 
                 GLOBAL USER { macro="MEASURE" | enable="_system.gRcuFocusedRobot.ToolMeasure.bConfigured"}
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "SETTOLERANCE") THEN
      IF NOT elem.kin.ToolMeasure.bConfigured THEN
         RcuResetMessage(EcoTalk_WarBKMacroIgnored, elem.kin.kinListInx, 13, 0, "EcoTalk.SETTOLERANCE", "SETTOLERANCE");
         RETURN;
      END_IF;
      elem.kin.ToolMeasure.SetTolerance(ToolNr, XMinus, XPlus, YMinus, YPlus, ZMinus, ZPlus);
   END_IF;
END_ROUTINE


// Wartet auf das Sensorsignal. Bei Erkennen des Sensorsignals wird gemaess
// der gewhlten Richtung die entsprechende kartesische Koordinate gespeichert
ROUTINE RECEIVE_LL_BASE(recordValue : COORD; object_LL : OBJECT) 
                    GLOBAL USER { macro="MEASURE" | enable="_system.gRcuFocusedRobot.ToolMeasure.bConfigured"}
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "RECEIVE_LL_BASE") THEN
      IF NOT elem.kin.ToolMeasure.bConfigured THEN
         RcuResetMessage(EcoTalk_WarBKMacroIgnored, elem.kin.kinListInx, 13, 0, "EcoTalk.RECEIVE_LL_BASE", "RECEIVE_LL_BASE");
         RETURN;
      END_IF;
      elem.kin.ToolMeasure.Receive_ll_base(recordValue, object_LL);
   END_IF;
END_ROUTINE


ROUTINE CALC_DISPLACED_OBJECT(VAR_IN SubSystemType  : TVisionSubSystemType;
                              VAR_IN Org : OBJECT;                      
                              Result : OBJECT)  : BOOL GLOBAL USER { macro="GEOMETRIC" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "CALC_DISPLACED_OBJECT") THEN	
      RETURN elem.kin.vision.MacroCalcObjectDisplacement(SubSystemType, Org, Result);
   END_IF;
   RETURN FALSE;
END_ROUTINE


ROUTINE CALC_DISPLACED_TOOL(VAR_IN SubSystemType  : TVisionSubSystemType;
                            VAR_IN Org : TOOL;                      
                            Result : TOOL)  : BOOL GLOBAL USER { macro="GEOMETRIC" }
   VAR
      elem : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "CALC_DISPLACED_TOOL") THEN	
      RETURN elem.kin.vision.MacroCalcToolDisplacement(SubSystemType, Org, Result);
   END_IF;
   RETURN FALSE;
END_ROUTINE

(******************************************************************************************************************
******************   Group  TC in Teachview - menu  ***************************************************************
******************************************************************************************************************)

ROUTINE TC_START(ToolNr : DINT) : BOOL GLOBAL USER { macro="TC" | enable="_system.gRcuFocusedRobot.vision.VisionTool.bCfgDataRead" }
VAR
   elem : TRcuKinListElem; // element with the kinematicreference
END_VAR
   
   IF RcData.CheckKin(elem, "TC_START") THEN
      IF NOT elem.kin.vision.VisionTool.bBootUpOk THEN
         RcuResetMessage(EcoTalk_WarBKMacroIgnored, elem.kin.kinListInx, 14, 0, "EcoTalk.TC_START", "TC_START"); // EcoTalk_WarBKMacroIgnored !!!!!!
         RETURN FALSE;
      END_IF;
      STOPPOINT();
      RETURN elem.kin.vision.VisionTool.TC_Start(ToolNr);
   ELSE
      RETURN FALSE;
   END_IF; 
END_ROUTINE


ROUTINE TC_SET_POS(PosNr : DINT) GLOBAL USER { macro="TC" | enable="_system.gRcuFocusedRobot.vision.VisionTool.bCfgDataRead" }
VAR
   elem : TRcuKinListElem; // element with the kinematicreference
END_VAR
   
   IF RcData.CheckKin(elem, "TC_SET_POS") THEN
      IF NOT elem.kin.vision.VisionTool.bBootUpOk THEN
         RcuResetMessage(EcoTalk_WarBKMacroIgnored, elem.kin.kinListInx, 15, 0, "EcoTalk.TC_SET_POS", "TC_SET_POS"); // EcoTalk_WarBKMacroIgnored !!!!!!
         RETURN;
      END_IF;
      STOPPOINT();
      elem.kin.vision.VisionTool.TC_SetPos(PosNr);
   END_IF;
   
END_ROUTINE


ROUTINE TC_RECEIVE_TOOL(refTool : TOOL; corrTool : TOOL) : BOOL GLOBAL USER { macro="TC" | enable="_system.gRcuFocusedRobot.vision.VisionTool.bCfgDataRead" }
VAR
   elem : TRcuKinListElem; // element with the kinematicreference
END_VAR
   
   IF RcData.CheckKin(elem, "TC_RECEIVE_TOOL") THEN
      IF NOT elem.kin.vision.VisionTool.bBootUpOk THEN
         RcuResetMessage(EcoTalk_WarBKMacroIgnored, elem.kin.kinListInx, 16, 0, "EcoTalk.TC_RECEIVE_TOOL", "TC_RECEIVE_TOOL"); // EcoTalk_WarBKMacroIgnored !!!!!!
         RETURN FALSE;
      END_IF;
      STOPPOINT();
      RETURN elem.kin.vision.VisionTool.TC_ReceiveTool(refTool, corrTool);
   ELSE
      RETURN FALSE;
   END_IF;
   
END_ROUTINE


(******************************************************************************************************************
******************   Group   SFA  in Teachview - menu  *********************************************************
******************************************************************************************************************)

ROUTINE RESET_SFA_COUNTER() GLOBAL USER { macro="SFA" | enable="_system.gRcuFocusedRobot.sfaRobot" }
    VAR
      elem  : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "RESET_SFA_COUNTER") THEN
      STOPPOINT();
      elem.kin.sfa.MacroResetCounter();
   END_IF;
END_ROUTINE  


ROUTINE CHECK_SFA_COUNTER(min : DINT; max : DINT) : BOOL GLOBAL USER { macro="SFA" | enable="_system.gRcuFocusedRobot.sfaRobot" }
    VAR
      elem  : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "CHECK_SFA_COUNTER") THEN
      STOPPOINT();
      RETURN elem.kin.sfa.MacroCheckCounter(min,max);
   ELSE
      RETURN FALSE;
   END_IF;
END_ROUTINE 


ROUTINE END_OF_TAPE() : BOOL GLOBAL USER { macro="SFA" | enable="_system.gRcuFocusedRobot.sfaRobot" }
    VAR
      elem  : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "END_OF_TAPE") THEN
      RETURN elem.kin.sfa.MacroEndOfTape();
   ELSE
      RETURN FALSE;
   END_IF;
END_ROUTINE 


ROUTINE PULSE_SFA_DRIVE(timer : DINT) GLOBAL USER { macro="SFA" | enable="_system.gRcuFocusedRobot.sfaRobot" }
    VAR
      elem  : TRcuKinListElem; // element with the kinematicreference
   END_VAR
   
   IF RcData.CheckKin(elem, "PULSE_SFA_DRIVE") THEN
      STOPPOINT();
      elem.kin.sfa.MacroPulseDrive(timer);
   END_IF;
END_ROUTINE  
 

ROUTINE SET_SFA_CMD(Cmd : SFA_CMD) GLOBAL USER { macro="SFA" | enable="_system.gRcuFocusedRobot.sfaRobot" }
   VAR
      elem  : TRcuKinListElem; // element with the kinematicreference
      s     : STRING;
      iLine : DINT;
      info  : TUserProgStackInfo;
   END_VAR
   
   IF RcData.CheckKin(elem, "SET_SFA_Cmd") THEN
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
          iLine := info.lineNrs[info.depth-1]; 
         ELSE
          iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      IF PaintRobot[elem.kin.kinListInx].sfaRobot THEN
         STOPPOINT();
         IF NOT elem.kin.sfa.MacroSetSFACmd(Cmd) THEN
            RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 14, 0, "Ecotalk.SET_SFA_CMD",  STR(iLine));
         END_IF; 
      ELSE
         //    RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 1, 0, "Ecotalk.SET_PLC_ORDER",  STR(iLine), "TRcuPreMainRun", STR(Run));
         elem.kin.ErrorReaction(TRUE);  
        // todo error: no sfa robot
      END_IF;
    END_IF; 
                            
END_ROUTINE


ROUTINE WAIT_SFA_STATE(state : SFA_STATE) GLOBAL USER { macro="SFA" | enable="_system.gRcuFocusedRobot.sfaRobot" }
    VAR
      elem  : TRcuKinListElem; // element with the kinematicreference
      iLine : DINT;
      info  : TUserProgStackInfo;
   END_VAR  
   
   IF RcData.CheckKin(elem, "WAIT_SFA_STATE") THEN
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
          iLine := info.lineNrs[info.depth-1]; 
         ELSE
          iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      IF PaintRobot[elem.kin.kinListInx].sfaRobot THEN
         STOPPOINT();
         IF NOT PaintRobot[elem.kin.kinListInx].sfa.MacroWaitSFAState(state) THEN
            RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 15, 0, "Ecotalk.WAIT_SFA_STATE",  STR(iLine));
         END_IF; 
      ELSE
         //    RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 1, 0, "Ecotalk.SET_PLC_ORDER",  STR(iLine), "TRcuPreMainRun", STR(Run));
         elem.kin.ErrorReaction(TRUE);  
        // todo error: no sfa robot
      END_IF; 
   END_IF;
END_ROUTINE


(******************************************************************************************************************
******************   Group  SmartRay in Teachview - menu  *********************************************************
******************************************************************************************************************)

TYPE GLOBAL USER 
   SMODE : (SR_DISTANCE, SR_POS, SR_BEGIN);
   SR_SIGNAL : (SR_START, SR_FINDCONTOUR, SR_TRACK, SR_AIR1, SR_AIR2);
END_TYPE

ROUTINE SR_SETSIGNAL(Signal : SR_SIGNAL; State : IOTYPE) GLOBAL USER { macro="SmartRay" | enable="_system.gRcuFocusedRobot.vision.VisionSmartRay.bCfgDataRead" }
VAR
   elem : TRcuKinListElem; // element with the kinematicreference
END_VAR
   
   IF RcData.CheckKin(elem, "SR_SETSIGNAL") THEN
      IF NOT elem.kin.vision.VisionSmartRay.bCfgDataRead THEN
         RcuResetMessage(EcoTalk_WarSRMacroIgnored, elem.kin.kinListInx, 1, 0, "EcoTalk.SR_SETSIGNAL", "SR_SETSIGNAL");
         RETURN;
      END_IF;
      START elem.kin.vision.VisionSmartRay.MacroSetSignal(Signal, State);
   END_IF;
   
END_ROUTINE


//ROUTINE SR_CONTROL(SignY : SIGN; State : IOTYPE) GLOBAL USER { macro="SmartRay" | enable="_system.gRcuFocusedRobot.vision.VisionSmartRay.bCfgDataRead" }
ROUTINE SR_CONTROL(State : IOTYPE) GLOBAL USER { macro="SmartRay" | enable="_system.gRcuFocusedRobot.vision.VisionSmartRay.bCfgDataRead" }
VAR
   elem : TRcuKinListElem; // element with the kinematicreference
END_VAR
   
   IF RcData.CheckKin(elem, "SR_CONTROL") THEN
      IF NOT elem.kin.vision.VisionSmartRay.bCfgDataRead THEN
         RcuResetMessage(EcoTalk_WarSRMacroIgnored, elem.kin.kinListInx, 2, 0, "EcoTalk.SR_CONTROL", "SR_CONTROL");
         RETURN;
      END_IF;
//      elem.kin.vision.VisionSmartRay.MacroSetOnlineCorr(SignY, State);
      elem.kin.vision.VisionSmartRay.MacroSetOnlineCorr(State);
   END_IF;
   
END_ROUTINE


ROUTINE SR_SEARCH(SearchMode : SMODE) GLOBAL USER { macro="SmartRay" | enable="_system.gRcuFocusedRobot.vision.VisionSmartRay.bCfgDataRead" }
VAR
   elem : TRcuKinListElem; // element with the kinematicreference
END_VAR
   
   IF RcData.CheckKin(elem, "SR_SEARCH") THEN
      IF NOT elem.kin.vision.VisionSmartRay.bCfgDataRead THEN
         RcuResetMessage(EcoTalk_WarSRMacroIgnored, elem.kin.kinListInx, 3, 0, "EcoTalk.RSR_SEARCH", "SR_SEARCH");
         RETURN;
      END_IF;
      START elem.kin.vision.VisionSmartRay.MacroStartSearch(SearchMode);
   END_IF;
   
END_ROUTINE


ROUTINE SR_SEARCHRESULT(P : POINT) : BOOL GLOBAL USER { macro="SmartRay" | enable="_system.gRcuFocusedRobot.vision.VisionSmartRay.bCfgDataRead" }
VAR
   elem : TRcuKinListElem; // element with the kinematicreference
END_VAR
   
   IF RcData.CheckKin(elem, "SR_SEARCHRESULT") THEN
      IF NOT elem.kin.vision.VisionSmartRay.bCfgDataRead THEN
         RcuResetMessage(EcoTalk_WarSRMacroIgnored, elem.kin.kinListInx, 4, 0, "EcoTalk.SR_SEARCHRESULT", "SR_SEARCHRESULT");
         RETURN FALSE;
      END_IF;
      RETURN elem.kin.vision.VisionSmartRay.MacroGetSearchResult(P);
   END_IF;
   RETURN FALSE;
END_ROUTINE

(******************************************************************************************************************
******************   Ende Group  SmartRay in Teachview - menu  ****************************************************
******************************************************************************************************************)


(******************************************************************************************************************
****************** Group  BCC in Teachview - menu *****************************************************************
******************************************************************************************************************)

//-----------------------------------------------------------------------------
// Get state from BCC Process for specified group and job
//-----------------------------------------------------------------------------
ROUTINE GET_PROCESS_STATE_BCC(Group : TRcuProcessGroup_BCC; Job : DINT ) : INT GLOBAL USER { macro="BCC" | enable="_system.gRcuFocusedRobot.bBccActive" }
  VAR
    iLine      : DINT;
    elem       : TRcuKinListElem; // element with the kinematicreference
    info       : TUserProgStackInfo;
    i          : INT;
    i2         : INT;
    iError     : INT := 99;
  END_VAR
  
  IF RcData.CheckKin(elem, "GET_PROCESS_STATE_BCC") THEN
    //Get Line of Teachprog for Error-Msg
    IF GetUserProgCallStackInfo(0, info) THEN
       IF info.depth > 0 THEN
          iLine := info.lineNrs[info.depth-1]; 
       ELSE
          iLine := info.lineNrs[0]; 
       END_IF;
    END_IF;
    
    IF NOT PaintRobot[elem.kin.kinListInx].bBccActive THEN
      RcuSetMessageOnce(EcoTalk_BccNotActive, elem.kin.kinListInx, 1, 0, "EcoTalk.GET_PROCESS_STATE", STR(iLine), "GET_PROCESS_STATE_BCC");
      elem.kin.ErrorReaction(TRUE);
    END_IF;
    
    IF NOT elem.kin.progPath.bAppendLate THEN  
       STOPPOINT();
       RcuSetMessageOnce(EcoTalk_ErrNoAppndLate, elem.kin.kinListInx, 2, 0, "EcoTalk.GET_PROCESS_STATE", STR(iLine), "GET_PROCESS_STATE_BCC");
       elem.kin.ErrorReaction(TRUE);
       RETURN iError;
    END_IF;
    
    CASE Group OF
       ToolDeskStatus : IF Job > PaintRobot[elem.kin.kinListInx].iMaxToolDesks_BCC THEN
                                 STOPPOINT();
                                 RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 13, 0, "Ecotalk.GET_PROCESS_STATE_BCC", STR(iLine), STR(Job), "ToolDeskStatus");
                                 elem.kin.ErrorReaction(TRUE);
                                 RETURN iError;
                        END_IF;
                        
                        i := 0;
                        i2:= 0;
                        IF PaintRobot[elem.kin.kinListInx].fieldbusIn.Spot1Empty.svBool = TRUE THEN
                           i  := i + 1;
                           i2 := 1;
                        END_IF;
                        IF PaintRobot[elem.kin.kinListInx].fieldbusIn.Spot2Empty.svBool = TRUE THEN
                           i  := i + 1;
                           i2 := 2;  
                        END_IF;
                        IF PaintRobot[elem.kin.kinListInx].fieldbusIn.Spot3Empty.svBool = TRUE THEN
                           i  := i + 1;
                           i2 := 3;
                        END_IF;
                        IF PaintRobot[elem.kin.kinListInx].fieldbusIn.Spot4Empty.svBool = TRUE THEN
                           i  := i + 1;
                           i2 := 4;  
                        END_IF;   
                        
                        IF i > 1 THEN
                           RcuSetMessageOnce(EcoTalk_ErrTableStateUndefined, elem.kin.kinListInx, 1, 0, "Ecotalk.GET_PROCESS_STATE_BCC", "ToolDeskStatus");
                           elem.kin.ErrorReaction(TRUE);                       
                        END_IF;
                        
                        IF i = 0  THEN
                            DebugPrint (eTraceCommon, "##  GET_PROCESS_STATE_BCC - ToolDeskStatus all ##");
                            DebugPrint (eTraceCommon, "##" +  STR(i2) + "##");                           
                            RETURN 0;

                        ELSE
                            CASE Job OF   
                              1  : DebugPrint (eTraceCommon, "##  GET_PROCESS_STATE_BCC - ToolDeskStatus 1 ##"); 
                                   DebugPrint (eTraceCommon, "##" +  STR(i2) + "##");
                                   RETURN i2; 
                               
                              2  : DebugPrint (eTraceCommon, "##  GET_PROCESS_STATE_BCC - ToolDeskStatus 2 ##"); 
                                   DebugPrint (eTraceCommon, "##" +  STR(i2) + "##");
                                   RETURN i2;
                              3  : DebugPrint (eTraceCommon, "##  GET_PROCESS_STATE_BCC - ToolDeskStatus 3 ##"); 
                                   DebugPrint (eTraceCommon, "##" +  STR(i2) + "##");
                                   RETURN i2;
                              4  : DebugPrint (eTraceCommon, "##  GET_PROCESS_STATE_BCC - ToolDeskStatus 4 ##"); 
                                   DebugPrint (eTraceCommon, "##" +  STR(i2) + "##");
                                   RETURN i2;    
                              END_CASE;                           
                        END_IF;                      

    ELSE  
       STOPPOINT();
       RcuSetMessageOnce(EcoTalk_ErrUnknownGroup, elem.kin.kinListInx, 7, 0, "Ecotalk.GET_PROCESS_STATE_BCC", STR(iLine), STR(Group), "GET_PROCESS_STATE_BCC");
       elem.kin.ErrorReaction(TRUE);
    END_CASE;
  END_IF;  
  
  RETURN iError;
END_ROUTINE


//-----------------------------------------------------------------------------
// Set state to BCC_Process for specified group and job
//-----------------------------------------------------------------------------
ROUTINE SET_PROCESS_STATE_BCC(Group : TRcuProcessGroup_BCC; Job : DINT) GLOBAL USER { macro="BCC" | enable="_system.gRcuFocusedRobot.bBccActive" }
  VAR
    elem    : TRcuKinListElem; // element with the kinematicreference
  END_VAR
  
  
  IF RcData.CheckKin(elem, "SET_PROCESS_STATE_BCC") THEN
    
        IF Job <> 99 THEN
         START SetProcessState_BCC(Group, Job);
        ELSE
         STOPPOINT();
         SetProcessState_BCC(Group, Job);
        END_IF;        

  END_IF;  

END_ROUTINE

//----------------------------------------------------------------------------------
// Set state to Motion for specified group and job in Prerun or according to mainrun
//----------------------------------------------------------------------------------
ROUTINE SetProcessState_BCC(Group : TRcuProcessGroup_BCC; Job : DINT) PRIVATE
  VAR
    iLine   : DINT;
    elem    : TRcuKinListElem; // element with the kinematicreference
    info    : TUserProgStackInfo;
    i1      : INT;
    i2      : INT;
    r1      : REAL;
    r2      : REAL;
    i3      : INT;
    i4      : INT;
  END_VAR
  
  IF RcData.CheckKin(elem, "SetProcessState_BCC") THEN
        MAINRUN();
     //Get Line of Teachprog for Error-Msg
     IF GetUserProgCallStackInfo(0, info) THEN
        IF info.depth > 0 THEN
           iLine := info.lineNrs[info.depth-1]; 
        ELSE
           iLine := info.lineNrs[0]; 
        END_IF;
     END_IF;

     IF NOT PaintRobot[elem.kin.kinListInx].bBccActive THEN
       RcuSetMessageOnce(EcoTalk_BccNotActive, elem.kin.kinListInx, 1, 0, "EcoTalk.SET_PROCESS_STATE_BCC", STR(iLine), "GET_PROCESS_STATE");
       elem.kin.ErrorReaction(TRUE);
     END_IF;

    PaintRobot[elem.kin.kinListInx].autoControl.ClearPlcInterface_BCC_EcoTalk();
     CASE Group OF
       Couple       :      IF (Job > PaintRobot[elem.kin.kinListInx].iMaxToolDesks_BCC) AND NOT (Job=99) THEN
                              RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 14, 0, "Ecotalk.SET_PROCESS_STATE_BCC", STR(iLine), STR(Job), "Couple");
                              elem.kin.ErrorReaction(TRUE);
                           END_IF;
       
                           CASE Job OF
                           0 :  DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Couple - clear ##");
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CoupleTool1.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CoupleTool2.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CoupleTool3.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CoupleTool4.svBool := FALSE;
                           1  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Couple 1 ##"); 
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CoupleTool1.svBool := TRUE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CoupleTool2.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CoupleTool3.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CoupleTool4.svBool := FALSE;
                           2  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Couple 2 ##"); 
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CoupleTool1.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CoupleTool2.svBool := TRUE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CoupleTool3.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CoupleTool4.svBool := FALSE;
                           3  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Couple 3 ##"); 
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CoupleTool1.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CoupleTool2.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CoupleTool3.svBool := TRUE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CoupleTool4.svBool := FALSE;
                           4  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Couple 4 ##"); 
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CoupleTool1.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CoupleTool2.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CoupleTool3.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CoupleTool4.svBool := TRUE;
                          99  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Couple Error ##");
                                RcuSetMessageOnce(EcoTalk_ErrDockingNotPossible, elem.kin.kinListInx, 1, 0, "Ecotalk.SET_PROCESS_STATE_BCC");
                                elem.kin.ErrorReaction(FALSE);                                                         
                        ELSE                      
                           RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 15, 0, "Ecotalk.SET_PROCESS_STATE_BCC", STR(iLine), STR(Job), "Couple");
                           elem.kin.ErrorReaction(TRUE);
                        END_CASE;
                     
       Uncouple       : IF (Job > PaintRobot[elem.kin.kinListInx].iMaxToolDesks_BCC) AND NOT (Job=99) THEN
                           RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 16, 0, "Ecotalk.SET_PROCESS_STATE_BCC", STR(iLine), STR(Job), "Uncouple");
                           elem.kin.ErrorReaction(TRUE);
                        END_IF; 
       
                        CASE Job OF          
                           0  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Uncouple - clear ##");
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.UncoupleTool1.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.UncoupleTool2.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.UncoupleTool3.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.UncoupleTool4.svBool := FALSE;

                           1  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Uncouple 1 ##"); 
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.UncoupleTool1.svBool := TRUE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.UncoupleTool2.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.UncoupleTool3.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.UncoupleTool4.svBool := FALSE;
                           2  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Uncouple 2 ##"); 
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.UncoupleTool1.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.UncoupleTool2.svBool := TRUE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.UncoupleTool3.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.UncoupleTool4.svBool := FALSE;
                           3  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Uncouple 3 ##"); 
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.UncoupleTool1.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.UncoupleTool2.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.UncoupleTool3.svBool := TRUE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.UncoupleTool4.svBool := FALSE;                        
                           4  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Uncouple 4 ##"); 
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.UncoupleTool1.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.UncoupleTool2.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.UncoupleTool3.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.UncoupleTool4.svBool := TRUE;
                          99  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Uncouple Error ##");
                                RcuSetMessageOnce(EcoTalk_ErrDeDockingNotPossible, elem.kin.kinListInx, 1, 0, "Ecotalk.SET_PROCESS_STATE_BCC");
                        ELSE                       
                           RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 17, 0, "Ecotalk.SET_PROCESS_STATE_BCC", STR(iLine), STR(Job), "Uncouple");
                           elem.kin.ErrorReaction(TRUE);
                        END_CASE;  
                     
       Lift       :     IF Job > PaintRobot[elem.kin.kinListInx].iMaxTool_BCC THEN
                           RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 18, 0, "Ecotalk.SET_PROCESS_STATE_BCC", STR(iLine), STR(Job), "Lift");
                           elem.kin.ErrorReaction(TRUE);
                        END_IF;
       
                        CASE Job OF
                           0  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Lift - clear ##");
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LiftTool1.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LiftTool2.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LiftTool3.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LiftTool4.svBool := FALSE;
                           1  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Lift 1 ##");
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LiftTool1.svBool := TRUE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LiftTool2.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LiftTool3.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LiftTool4.svBool := FALSE;
                           2  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Lift 2 ##");
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LiftTool1.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LiftTool2.svBool := TRUE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LiftTool3.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LiftTool4.svBool := FALSE;
                           3  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Lift 3 ##"); 
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LiftTool1.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LiftTool2.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LiftTool3.svBool := TRUE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LiftTool4.svBool := FALSE;
                           4  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Lift 4 ##");
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LiftTool1.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LiftTool2.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LiftTool3.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LiftTool4.svBool := TRUE;

                        ELSE                        
                           RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 19, 0, "Ecotalk.SET_PROCESS_STATE_BCC", STR(iLine), STR(Job), "Couple");
                           elem.kin.ErrorReaction(TRUE);
                        END_CASE;
                     
       Lower       :    IF (Job > PaintRobot[elem.kin.kinListInx].iMaxTool_BCC) AND NOT (Job=99) THEN
                           RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 20, 0, "Ecotalk.SET_PROCESS_STATE_BCC", STR(iLine), STR(Job), "Lower");
                           elem.kin.ErrorReaction(TRUE);
                        END_IF;    
       
                        CASE Job OF
                           0  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Lower - clear ##");
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool1.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool2.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool3.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool4.svBool := FALSE;          
                           1  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Lower 1 ##"); 
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool1.svBool := TRUE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool2.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool3.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool4.svBool := FALSE;
                           2  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Lower 2 ##"); 
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool1.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool2.svBool := TRUE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool3.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool4.svBool := FALSE;
                           3  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Lower 3 ##"); 
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool1.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool2.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool3.svBool := TRUE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool4.svBool := FALSE;
                           4  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Lower 4 ##"); 
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool1.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool2.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool3.svBool := FALSE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool4.svBool := TRUE;
                           99 : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Lower all##");
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool1.svBool := TRUE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool2.svBool := TRUE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool3.svBool := TRUE;
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.LowerTool4.svBool := TRUE;
                        ELSE                       
                           RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 21, 0, "Ecotalk.SET_PROCESS_STATE_BCC", STR(iLine), STR(Job), "Uncouple");
                           elem.kin.ErrorReaction(TRUE);
                        END_CASE;
                     
       PrcStart :       IF ((Job > 32768) OR (Job <= 0)) THEN                    
                           RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 22, 0, "Ecotalk.SET_PROCESS_STATE_BCC", STR(iLine), STR(Job), "PrcStart");
                           elem.kin.ErrorReaction(TRUE);
                        ELSE
                           PaintRobot[elem.kin.kinListInx].fieldbusOut.HoleNumber.svWord := Job;
                           DebugPrint (eTraceCommon, "##  SetProcessState_BCC - HoleNumber " + STR(Job) + " ##");                        
                           PaintRobot[elem.kin.kinListInx].fieldbusOut.ApplicationStart.svBool := TRUE;
                           DebugPrint (eTraceCommon, "##  SetProcessState_BCC - ApplicationStart ##" + STR(Job));
                        END_IF;          
               
                     
       Collision     :  CASE Job OF
                           0  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Collision 0 ##");
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CollisionType.svBool := FALSE;
                           1  : DebugPrint (eTraceCommon, "##  SetProcessState_BCC - Collision 1 ##"); 
                                PaintRobot[elem.kin.kinListInx].fieldbusOut.CollisionType.svBool := TRUE;
                        ELSE                      
                           RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 23, 0, "Ecotalk.SET_PROCESS_STATE_BCC", STR(iLine), STR(Job), "Collision");
                           elem.kin.ErrorReaction(TRUE);
                        END_CASE;                    
     
     CheckNozzle     : i1 := (Job /10);
                              i2 := Job - (i1*10);                               
                       IF ( (i1 >= 1) AND (i1 <= (PaintRobot[elem.kin.kinListInx].iMaxToolDesks_BCC)) AND ((i2 >= 1) AND (i2 <= (PaintRobot[elem.kin.kinListInx].iMaxTool_BCC)))) THEN                             
                           IF PaintRobot[elem.kin.kinListInx].fieldbusIn.NozzleSensor.svBool = FALSE THEN
                              DebugPrint (eTraceCommon, "##  SetProcessState_BCC - CheckNozzle ##" + STR(Job) + STR(i1) + STR(i2)); 
                              RcuSetMessageOnce(EcoTalk_ErrNozzleTestFailed, elem.kin.kinListInx, 1, 0, "Ecotalk.GET_PROCESS_STATE_BCC", STR(i2), STR(i1));
                              elem.kin.ErrorReaction(TRUE);
                           END_IF;
                   
                        ELSE                  
                           RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 24, 0, "Ecotalk.SET_PROCESS_STATE_BCC", STR(iLine), STR(Job), "CheckNozzle");
                           elem.kin.ErrorReaction(TRUE);
                        END_IF;
 
      CheckAllNozzles   : i1 := (Job /10);
                       i2 := Job - (i1*10); 
                       IF ( (i1 >= 1) AND (i1 <= (PaintRobot[elem.kin.kinListInx].iMaxToolDesks_BCC)) AND ((i2 >= 1) AND (i2 <= (PaintRobot[elem.kin.kinListInx].iMaxTool_BCC)))) THEN                             
                           IF PaintRobot[elem.kin.kinListInx].fieldbusIn.NozzleSensor.svBool = FALSE THEN
                              DebugPrint (eTraceCommon, "##  SetProcessState_BCC - CheckNozzle ##" + STR(Job) + STR(i1) + STR(i2)); 
                              RcuResetMessage(EcoTalk_WarNozzleTestFailed, elem.kin.kinListInx, 1, Job, "Ecotalk.GET_PROCESS_STATE_BCC", STR(i2), STR(i1));
                           END_IF;
                   
                        ELSE                  
                           RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 24, 0, "Ecotalk.SET_PROCESS_STATE_BCC", STR(iLine), STR(Job), "CheckNozzle");
                           elem.kin.ErrorReaction(TRUE);
                        END_IF; 
                     
     ELSE
        MAINRUN();
        RcuSetMessageOnce(EcoTalk_ErrUnknownGroup, elem.kin.kinListInx, 8, 0, "Ecotalk.SET_PROCESS_STATE_BCC", STR(iLine), STR(Group), "SET_PROCESS_STATE_BCC");
        elem.kin.ErrorReaction(TRUE);
     END_CASE;
  END_IF;

END_ROUTINE


//-----------------------------------------------------------------------------
// Wait until BCC_Process signals requested state for specified group and job
//-----------------------------------------------------------------------------
ROUTINE WAIT_PROCESS_STATE_BCC(Group : TRcuProcessGroup_BCC; Job : DINT) : BOOL GLOBAL USER { macro="BCC" | enable="_system.gRcuFocusedRobot.bBccActive" }
  VAR
    iLine   : DINT;
    elem    : TRcuKinListElem; // element with the kinematicreference
    info    : TUserProgStackInfo;
  END_VAR
  
  IF RcData.CheckKin(elem, "WAIT_PROCESS_STATE_BCC") THEN
     STOPPOINT();
     //Get Line of Teachprog for Error-Msg
     IF GetUserProgCallStackInfo(0, info) THEN
        IF info.depth > 0 THEN
           iLine := info.lineNrs[info.depth-1]; 
        ELSE
           iLine := info.lineNrs[0]; 
        END_IF;
     END_IF;
     
     IF NOT PaintRobot[elem.kin.kinListInx].bBccActive THEN
       RcuSetMessageOnce(EcoTalk_BccNotActive, elem.kin.kinListInx, 1, 0, "EcoTalk.GET_PROCESS_STATE_BCC", STR(iLine), "GET_PROCESS_STATE");
       elem.kin.ErrorReaction(TRUE);
     END_IF;
     
     CASE Group OF              
         Couple       : IF Job > PaintRobot[elem.kin.kinListInx].iMaxToolDesks_BCC THEN
                           RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 25, 0, "Ecotalk.WAIT_PROCESS_STATE_BCC", STR(iLine), STR(Job), "Couple");
                           elem.kin.ErrorReaction(TRUE);
                        END_IF;  
         
                        CASE Job OF
                           0  : DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_BCC - Couple 0 ##");
                                WAIT (NOT PaintRobot[elem.kin.kinListInx].fieldbusIn.Spot1Empty.svBool AND NOT PaintRobot[elem.kin.kinListInx].fieldbusIn.Spot2Empty.svBool AND NOT 
                                   PaintRobot[elem.kin.kinListInx].fieldbusIn.Spot3Empty.svBool AND NOT PaintRobot[elem.kin.kinListInx].fieldbusIn.Spot4Empty.svBool);
                                DebugPrint (eTraceCommon, "##" + STR( (NOT PaintRobot[elem.kin.kinListInx].fieldbusIn.Spot1Empty.svBool AND NOT PaintRobot[elem.kin.kinListInx].fieldbusIn.Spot2Empty.svBool AND NOT 
                                   PaintRobot[elem.kin.kinListInx].fieldbusIn.Spot3Empty.svBool AND NOT PaintRobot[elem.kin.kinListInx].fieldbusIn.Spot4Empty.svBool)));
                           1  : DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_BCC - Couple 1 ##");
                                WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.CouplingTool1Done.svBool;

                           2  : DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_BCC - Couple 2 ##");
                                WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.CouplingTool2Done.svBool;
                           3  : DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_BCC - Couple 3 ##");
                                WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.CouplingTool3Done.svBool;
                           4  : DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_BCC - Couple 4 ##");
                                WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.CouplingTool4Done.svBool;

                        ELSE  

                           RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 26, 0, "Ecotalk.WAIT_PROCESS_STATE_BCC", STR(iLine), STR(Job), "Couple");
                           elem.kin.ErrorReaction(TRUE);
                        END_CASE;
      
         Uncouple     : IF Job > PaintRobot[elem.kin.kinListInx].iMaxToolDesks_BCC THEN
                           RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 27, 0, "Ecotalk.WAIT_PROCESS_STATE_BCC", STR(iLine), STR(Job), "Uncouple");
                           elem.kin.ErrorReaction(TRUE);
                        END_IF; 
         
                           CASE Job OF                       
                           1  : DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_BCC - Uncouple 1 ##");
                                WAIT (NOT PaintRobot[elem.kin.kinListInx].fieldbusIn.Spot1Empty.svBool);
                           2  : DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_BCC - Uncouple 2 ##");
                                WAIT (NOT PaintRobot[elem.kin.kinListInx].fieldbusIn.Spot2Empty.svBool);
                           3  : DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_BCC - Uncouple 3 ##");
                                WAIT (NOT PaintRobot[elem.kin.kinListInx].fieldbusIn.Spot3Empty.svBool);
                           4  : DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_BCC - Uncouple 4 ##");
                                WAIT (NOT PaintRobot[elem.kin.kinListInx].fieldbusIn.Spot4Empty.svBool);

                        ELSE                       
                           RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 28, 0, "Ecotalk.WAIT_PROCESS_STATE_BCC", STR(iLine), STR(Job), "Couple");
                           elem.kin.ErrorReaction(TRUE);
                        END_CASE; 
 
       Lift      :     IF Job > PaintRobot[elem.kin.kinListInx].iMaxTool_BCC THEN
                           RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 29, 0, "Ecotalk.SET_PROCESS_STATE_BCC", STR(iLine), STR(Job), "Lift");
                           elem.kin.ErrorReaction(TRUE);
                        END_IF;  
          
                        CASE Job OF
                           1  : DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_BCC - Lift 1 ##");
                                WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.Tool1Lifted.svBool;
                           2  : DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_BCC - Lift 2 ##"); 
                                WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.Tool2Lifted.svBool;
                           3  : DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_BCC - Lift 3 ##"); 
                                WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.Tool3Lifted.svBool;
                           4  : DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_BCC - Lift 4 ##");
                                WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.Tool4Lifted.svBool;
                        ELSE                       
                           RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 30, 0, "Ecotalk.WAIT_PROCESS_STATE_BCC", STR(iLine), STR(Job), "Lift");
                           elem.kin.ErrorReaction(TRUE);
                        END_CASE;
                     
        Lower       :   IF (Job > PaintRobot[elem.kin.kinListInx].iMaxTool_BCC) AND NOT (Job=99) THEN
                           RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 31, 0, "Ecotalk.SET_PROCESS_STATE_BCC", STR(iLine), STR(Job), "Lower");
                           elem.kin.ErrorReaction(TRUE);
                        END_IF;
          
                        CASE Job OF
                           1  : DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_BCC - Lower 1 ##"); //RETURN ;
                                WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.Tool1Lowered.svBool;
                           2  : DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_BCC - Lower 2 ##"); //RETURN ;
                                WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.Tool2Lowered.svBool;                        
                           3  : DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_BCC - Lower 3 ##"); //RETURN ;
                                WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.Tool3Lowered.svBool;                        
                           4  : DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_BCC - Lower 4 ##"); //RETURN ;
                                WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.Tool4Lowered.svBool;
                          99  : DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_BCC - Lower 99 ##"); //RETURN ;
                                WAIT (PaintRobot[elem.kin.kinListInx].fieldbusIn.Tool1Lowered.svBool AND PaintRobot[elem.kin.kinListInx].fieldbusIn.Tool2Lowered.svBool AND
                                      PaintRobot[elem.kin.kinListInx].fieldbusIn.Tool3Lowered.svBool AND PaintRobot[elem.kin.kinListInx].fieldbusIn.Tool4Lowered.svBool);   
                        ELSE                        
                           RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 32, 0, "Ecotalk.WAIT_PROCESS_STATE_BCC", STR(iLine), STR(Job), "Couple");
                           elem.kin.ErrorReaction(TRUE);
                        END_CASE;                     
                     
          PrcDone    :  IF ((Job > 32768) OR (Job < 0)) THEN

                              RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 33, 0, "Ecotalk.WAIT_PROCESS_STATE_BCC", STR(iLine), STR(Job), "Uncouple");
                              elem.kin.ErrorReaction(TRUE);
                           END_IF;
                           WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.ApplicationDone.svBool;
                           DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_BCC - ApplicationDone ##"); 
                           PaintRobot[elem.kin.kinListInx].fieldbusOut.HoleNumber.svWord    := 0;
                           PaintRobot[elem.kin.kinListInx].fieldbusOut.ApplicationStart.svBool := FALSE;
                           IF NOT (Job = PaintRobot[elem.kin.kinListInx].fieldbusIn.HoleNumber.svWord)  THEN
                           RcuSetMessageOnce(EcoTalk_ErrWrongHoleNumber, elem.kin.kinListInx, 1, 0, "Ecotalk.WAIT_PROCESS_STATE_BCC", STR(iLine), STR(Job), STR(PaintRobot[elem.kin.kinListInx].fieldbusIn.HoleNumber.svWord));                      
                           elem.kin.ErrorReaction(TRUE);
                        END_IF;          
     
     ELSE
        RcuSetMessageOnce(EcoTalk_ErrUnknownGroup, elem.kin.kinListInx, 9, 0, "Ecotalk.WAIT_PROCESS_STATE_BCC", STR(iLine), STR(Group), "WAIT_PROCESS_STATE_BCC");
        elem.kin.ErrorReaction(TRUE);
        RETURN FALSE;
     END_CASE;
  END_IF;
  RETURN FALSE;
  
END_ROUTINE

// PI

ROUTINE WAIT_PROCESS_STATE_PI(Group : TRcuProcessGroup_PI) : BOOL GLOBAL USER { macro="PI" | enable="_system.gRcuFocusedRobot.bActivatePlacePlug" }
   
 VAR
    iLine   : DINT;
    elem    : TRcuKinListElem; // element with the kinematicreference
    info    : TUserProgStackInfo;
  END_VAR
  
     IF RcData.CheckKin(elem, "WAIT_PROCESS_STATE_PI") THEN
      STOPPOINT();
      //Get Line of Teachprog for Error-Msg
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
              iLine := info.lineNrs[info.depth-1]; 
         ELSE
              iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
       IF NOT PaintRobot[elem.kin.kinListInx].bActivatePlacePlug THEN
         RcuSetMessageOnce(EcoTalk_PsNotActive, elem.kin.kinListInx, 1, 0, "EcoTalk.WAIT_PROCESS_STATE_PI", STR(iLine), "WAIT_PROCESS_STATE_PI");
         elem.kin.ErrorReaction(TRUE);
       END_IF;
       CASE Group OF              
         PlacePlug :  
           WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.PlacePlugOK.svBool;
           DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_PI - PlacePlug ##");
           PaintRobot[elem.kin.kinListInx].fieldbusOut.HoleNumber.svWord    := 0;
         CheckPlug :  
           WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.CheckPlugOK.svBool;
           DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_PI - CheckPlug ##");
           PaintRobot[elem.kin.kinListInx].fieldbusOut.HoleNumber.svWord    := 0;
         FillingDone    : 
           DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_PI - FillingDone ##");
           WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.FillingMagazineDone.svBool;  
         Couple_PI      :
           DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_PI - Couple_PI ##");
           WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.CouplingToolDone_PI.svBool;
         Uncouple_PI      :
           DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_PI - Uncouple_PI ##");
           WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.UncouplingToolDone_PI.svBool;
         GetPlug      :
           DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_PI - GetPlug_PI ##");
           WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.GetPlugDone.svBool;
         PlugMagazinDischarged :
           DebugPrint (eTraceCommon, "##  WAIT_PROCESS_STATE_PI - MagazinDischarged ##");
           WAIT PaintRobot[elem.kin.kinListInx].fieldbusIn.MagazinDischarged.svBool;
           PaintRobot[elem.kin.kinListInx].fieldbusOut.DiscargePlugMagazin.svBool := FALSE;
         
      ELSE
        RcuSetMessageOnce(EcoTalk_ErrUnknownGroup, elem.kin.kinListInx, 10, 0, "Ecotalk.WAIT_PROCESS_STATE_PI", STR(iLine), STR(Group), "WAIT_PROCESS_STATE_PI");
        elem.kin.ErrorReaction(TRUE);
        RETURN FALSE; 
      END_CASE;
     END_IF;
     RETURN FALSE;
END_ROUTINE

//-----------------------------------------------------------------------------
// Set state to BCC_Process for specified group and job
//-----------------------------------------------------------------------------
ROUTINE SET_PROCESS_STATE_PI(Group : TRcuProcessGroup_PI; Job : DINT) GLOBAL USER { macro="PI" | enable="_system.gRcuFocusedRobot.bActivatePlacePlug" }
  VAR
    elem    : TRcuKinListElem; // element with the kinematicreference
  END_VAR
  
  
  IF RcData.CheckKin(elem, "SET_PROCESS_STATE_PI") THEN
      START SetProcessState_PI(Group,Job);
  END_IF;  

END_ROUTINE

ROUTINE SetProcessState_PI(Group : TRcuProcessGroup_PI; Job : DINT ) PRIVATE { macro="PI" | enable="_system.gRcuFocusedRobot.bActivatePlacePlug" }
   
 VAR
    iLine   : DINT;
    elem    : TRcuKinListElem; // element with the kinematicreference
    info    : TUserProgStackInfo;
  END_VAR
  
     IF RcData.CheckKin(elem, "SET_PROCESS_STATE_PI") THEN
      MAINRUN();
      //Get Line of Teachprog for Error-Msg
      IF GetUserProgCallStackInfo(0, info) THEN
        IF info.depth > 0 THEN
             iLine := info.lineNrs[info.depth-1]; 
        ELSE
             iLine := info.lineNrs[0]; 
        END_IF;
      END_IF;
      
      IF NOT PaintRobot[elem.kin.kinListInx].bActivatePlacePlug THEN
        RcuSetMessageOnce(EcoTalk_PsNotActive, elem.kin.kinListInx, 2, 0, "EcoTalk.SET_PROCESS_STATE_PI", STR(iLine), "SET_PROCESS_STATE_PI");
        elem.kin.ErrorReaction(TRUE);
      END_IF;
      PaintRobot[elem.kin.kinListInx].autoControl.ClearPlcInterface_BCC_EcoTalk();       
      CASE Group OF              
         PlacePlug :  
           IF ((Job > 32768) OR (Job <= 0)) THEN                    
             RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 22, 0, "Ecotalk.SET_PROCESS_STATE_BCC_PI", STR(iLine), STR(Job), "PlacePlug");
             elem.kin.ErrorReaction(TRUE);
           ELSE
             PaintRobot[elem.kin.kinListInx].fieldbusOut.HoleNumber.svWord := Job;
             DebugPrint (eTraceCommon, "##  SET_PROCESS_STATE_PI - HoleNumber " + STR(Job) + " ##");
             PaintRobot[elem.kin.kinListInx].fieldbusOut.PlacePlug.svBool := TRUE;
             DebugPrint (eTraceCommon, "##  SET_PROCESS_STATE_PI - PlacePlug ##");
           END_IF;
         CheckPlug :  
           IF ((Job > 32768) OR (Job <= 0)) THEN                    
             RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 22, 0, "Ecotalk.SET_PROCESS_STATE_BCC_PI", STR(iLine), STR(Job), "CheckPlug");
             elem.kin.ErrorReaction(TRUE);
           ELSE
             PaintRobot[elem.kin.kinListInx].fieldbusOut.HoleNumber.svWord := Job;
             DebugPrint (eTraceCommon, "##  SET_PROCESS_STATE_PI - HoleNumber " + STR(Job) + " ##");
             PaintRobot[elem.kin.kinListInx].fieldbusOut.CheckPlug.svBool := TRUE;  
             DebugPrint (eTraceCommon, "##  SET_PROCESS_STATE_PI - CheckPlug ##");
           END_IF;
         StartFilling :  
           DebugPrint (eTraceCommon, "##  SET_PROCESS_STATE_PI - StartFilling ##");
           PaintRobot[elem.kin.kinListInx].fieldbusOut.FillMagazine.svBool := TRUE;  
         Couple_PI :
           CASE Job OF
             99 :
             RcuSetMessageOnce(EcoTalk_ErrDockingNotPossible, elem.kin.kinListInx, 1, 0, "Ecotalk.SET_PROCESS_STATE_PI");
           ELSE
             DebugPrint (eTraceCommon, "##  SET_PROCESS_STATE_PI - Couple_PI ##");
             PaintRobot[elem.kin.kinListInx].fieldbusOut.CoupleTool_PI.svBool := TRUE;        
           END_CASE;
       
         Uncouple_PI :
           CASE Job OF
             99 :
             RcuSetMessageOnce(EcoTalk_ErrDeDockingNotPossible, elem.kin.kinListInx, 1, 0, "Ecotalk.SET_PROCESS_STATE_PI");
           ELSE
             DebugPrint (eTraceCommon, "##  SET_PROCESS_STATE_PI - Uncouple_PI ##");
             PaintRobot[elem.kin.kinListInx].fieldbusOut.UncoupleTool_PI.svBool := TRUE;     
           END_CASE;
         Collision_PI     :  
            CASE Job OF
               0  : DebugPrint (eTraceCommon, "##  SetProcessState_PI - Collision 0 ##");
                    PaintRobot[elem.kin.kinListInx].fieldbusOut.CollisionType.svBool := FALSE;
               1  : DebugPrint (eTraceCommon, "##  SetProcessState_PI - Collision 1 ##");                                 
                    PaintRobot[elem.kin.kinListInx].fieldbusOut.CollisionType.svBool := TRUE;
            ELSE                      
               RcuSetMessageOnce(EcoTalk_ErrWrongJob, elem.kin.kinListInx, 34, 0, "Ecotalk.SET_PROCESS_STATE_PI", STR(iLine), STR(Job), "Collision_PI");
               elem.kin.ErrorReaction(TRUE);
           END_CASE;
         
         GetPlug :
           PaintRobot[elem.kin.kinListInx].fieldbusOut.GetPlug.svBool := TRUE;
           DebugPrint (eTraceCommon, "##  SET_PROCESS_STATE_PI - GetPlug ##");
         
         DiscargePlugMagazin :
           DebugPrint (eTraceCommon, "##  SET_PROCESS_STATE_PI - DiscargePlugMagazin ##");
           PaintRobot[elem.kin.kinListInx].fieldbusOut.DiscargePlugMagazin.svBool := TRUE;         
    
      ELSE
        MAINRUN();
        RcuSetMessageOnce(EcoTalk_ErrUnknownGroup, elem.kin.kinListInx, 11, 0, "Ecotalk.WAIT_PROCESS_STATE_PI", STR(iLine), STR(Group), "WAIT_PROCESS_STATE_PI");
        elem.kin.ErrorReaction(TRUE);
      END_CASE;
     END_IF;
END_ROUTINE


ROUTINE GET_PROCESS_STATE_PI(Group : TRcuProcessGroup_PI) : INT GLOBAL USER { macro="PI" | enable="_system.gRcuFocusedRobot.bActivatePlacePlug" }
  VAR
    iLine      : DINT;
    elem       : TRcuKinListElem; // element with the kinematicreference
    info       : TUserProgStackInfo;
    i          : INT;
    i2         : INT;
    iError     : INT := 99;
  END_VAR
  
  IF RcData.CheckKin(elem, "GET_PROCESS_STATE_PI") THEN
    //Get Line of Teachprog for Error-Msg
    IF GetUserProgCallStackInfo(0, info) THEN
       IF info.depth > 0 THEN
          iLine := info.lineNrs[info.depth-1]; 
       ELSE
          iLine := info.lineNrs[0]; 
       END_IF;
    END_IF;
    
    IF NOT PaintRobot[elem.kin.kinListInx].bActivatePlacePlug THEN
      RcuSetMessageOnce(EcoTalk_PsNotActive, elem.kin.kinListInx, 3, 0, "EcoTalk.GET_PROCESS_STATE_PI", STR(iLine), "GET_PROCESS_STATE_PI");
      elem.kin.ErrorReaction(TRUE);
    END_IF;
    
    IF NOT elem.kin.progPath.bAppendLate THEN  
       STOPPOINT();
       RcuSetMessageOnce(EcoTalk_ErrNoAppndLate, elem.kin.kinListInx, 4, 0, "EcoTalk.GET_PROCESS_STATE_PI", STR(iLine), "GET_PROCESS_STATE_PI");
       elem.kin.ErrorReaction(TRUE);
       RETURN iError;
    END_IF;
    
    CASE Group OF
       ToolDeskStatus_PI :                         
         i := 0;
         i2:= 0;
         IF PaintRobot[elem.kin.kinListInx].fieldbusIn.SpotEmpty_PI.svBool = TRUE THEN
            i  := 1;                       
         END_IF;
         RETURN i;
       PlugCheck :
         i := 0;
         i2:= 0;
         IF PaintRobot[elem.kin.kinListInx].fieldbusIn.PlugCheckOk.svBool = TRUE THEN
            i  := 1;
         END_IF;
         RETURN i;
    ELSE  
       STOPPOINT();
       RcuSetMessageOnce(EcoTalk_ErrUnknownGroup, elem.kin.kinListInx, 12, 0, "Ecotalk.GET_PROCESS_STATE_BCC", STR(iLine), STR(Group), "GET_PROCESS_STATE_BCC");
       elem.kin.ErrorReaction(TRUE);
    END_CASE;
  END_IF;  
  
  RETURN iError;
END_ROUTINE

(******************************************************************************************************************
****************** Ende Group  BCC in Teachview - menu ************************************************************
******************************************************************************************************************)


(******************************************************************************************************************
****************** Group NC (Nozzle Change) in Teachview - menu ***************************************************
******************************************************************************************************************)

ROUTINE NC_SET_NOZZLE(mainNeedle : DINT; nozzleNr : DINT) GLOBAL USER { macro="NC" | enable="_system.gRcuFocusedRobot.nozzleChange.hasNozzleChangeBool" }
   
   VAR
      iLine : DINT;
      elem  : TRcuKinListElem; // element with the kinematicreference
      info  : TUserProgStackInfo;
      nC    : MAPTO TRcuNozzleChange;
   END_VAR
   
   IF RcData.CheckKin(elem, "NC_SET_NOZZLE") THEN
      
      // Get Line of Teachprog for Error-Msg
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
            iLine := info.lineNrs[info.depth-1]; 
         ELSE
            iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      STOPPOINT();
      
      nC := MAP(PaintRobot[elem.kin.kinListInx].nozzleChange);
      
      IF (mainNeedle < 1) OR (mainNeedle > 3) THEN
         RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 16, 0, "Ecotalk.NC_SET_NOZZLE", STR(iLine), "NC_SET_NOZZLE", "mainNeedle");
         elem.kin.ErrorReaction(TRUE);
      END_IF;
      
      nC.nextMainNeedle := mainNeedle;
      nC.nextNozzleNr := nozzleNr;
      nC.svNozzleGun := mainNeedle; // signal next main needle to PCU
      
   END_IF;
   
END_ROUTINE


ROUTINE NC_NOZZLE_CHANGE() : BOOL GLOBAL USER { macro="NC" | enable="_system.gRcuFocusedRobot.nozzleChange.hasNozzleChangeBool" }
   
   VAR
      iLine : DINT;
      elem  : TRcuKinListElem; // element with the kinematicreference
      info  : TUserProgStackInfo;
      nC    : MAPTO TRcuNozzleChange;
   END_VAR
   
   IF RcData.CheckKin(elem, "NC_NOZZLE_CHANGE") THEN
      
      // Get Line of Teachprog for Error-Msg
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
            iLine := info.lineNrs[info.depth-1]; 
         ELSE
            iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      STOPPOINT();
      
      nC := MAP(PaintRobot[elem.kin.kinListInx].nozzleChange);
      
      IF (nC.svMainNeedles[nC.nextMainNeedle].iNozzleNr = nC.nextNozzleNr)
         AND nC.svMainNeedles[nC.nextMainNeedle].mOccupied
         AND nC.svMainNeedles[nC.nextMainNeedle].mOK
      THEN
         RETURN FALSE;
      ELSE
         RETURN TRUE;
      END_IF;
      
   END_IF;
   
   RETURN FALSE;
   
END_ROUTINE


ROUTINE NC_NOZZLE_AT_ROBOT() : BOOL GLOBAL USER { macro="NC" | enable="_system.gRcuFocusedRobot.nozzleChange.hasNozzleChangeBool" }
   
   VAR
      iLine : DINT;
      elem  : TRcuKinListElem; // element with the kinematicreference
      info  : TUserProgStackInfo;
      nC    : MAPTO TRcuNozzleChange;
   END_VAR
   
   IF RcData.CheckKin(elem, "NC_NOZZLE_AT_ROBOT") THEN
      
      // Get Line of Teachprog for Error-Msg
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
            iLine := info.lineNrs[info.depth-1]; 
         ELSE
            iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      STOPPOINT();
      
      nC := MAP(PaintRobot[elem.kin.kinListInx].nozzleChange);
      
      IF nC.svMainNeedles[nC.nextMainNeedle].mOccupied THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END_IF;
      
   END_IF;
   
   RETURN FALSE;
   
END_ROUTINE


ROUTINE NC_PLACE_FREE(changerPlace : DINT) : BOOL GLOBAL USER { macro="NC" | enable="_system.gRcuFocusedRobot.nozzleChange.hasNozzleChangeBool" }
   
   VAR
      iLine : DINT;
      elem  : TRcuKinListElem; // element with the kinematicreference
      info  : TUserProgStackInfo;
      nC    : MAPTO TRcuNozzleChange;
      i     : INT;
      bSpecialPlace : BOOL;
      
   END_VAR
   
   IF RcData.CheckKin(elem, "NC_PLACE_FREE") THEN
      
      // Get Line of Teachprog for Error-Msg
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
            iLine := info.lineNrs[info.depth-1]; 
         ELSE
            iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      STOPPOINT();
      
      nC := MAP(PaintRobot[elem.kin.kinListInx].nozzleChange);
      
      IF (changerPlace < 1) OR (changerPlace > nC.svNrOfPlaces) THEN
         RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 17, 0, "Ecotalk.NC_PLACE_FREE", STR(iLine), "NC_PLACE_FREE", "changerPlace");
         elem.kin.ErrorReaction(TRUE);
      END_IF;
      
      bSpecialPlace := FALSE;
      FOR i:=1 TO nC.svNrOfPlaces DO
         IF (nC.svChangerPlaces[i].iForNozzleNr = nC.svMainNeedles[nC.nextMainNeedle].iNozzleNr) THEN
            bSpecialPlace := TRUE;
         END_IF;
      END_FOR;
      
      IF NOT nC.svChangerPlaces[changerPlace].mOccupied
         AND (((nC.svChangerPlaces[changerPlace].iForNozzleNr = 0) AND NOT bSpecialPlace)
            OR (nC.svChangerPlaces[changerPlace].iForNozzleNr = nC.svMainNeedles[nC.nextMainNeedle].iNozzleNr))
      THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END_IF;
      
   END_IF;
   
   RETURN FALSE;
   
END_ROUTINE


ROUTINE NC_NOZZLE_IN_PLACE(changerPlace : DINT) : BOOL GLOBAL USER { macro="NC" | enable="_system.gRcuFocusedRobot.nozzleChange.hasNozzleChangeBool" }
   
   VAR
      iLine : DINT;
      elem  : TRcuKinListElem; // element with the kinematicreference
      info  : TUserProgStackInfo;
      nC    : MAPTO TRcuNozzleChange;
   END_VAR
   
   IF RcData.CheckKin(elem, "NC_NOZZLE_IN_PLACE") THEN
      
      // Get Line of Teachprog for Error-Msg
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
            iLine := info.lineNrs[info.depth-1]; 
         ELSE
            iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      STOPPOINT();
      
      nC := MAP(PaintRobot[elem.kin.kinListInx].nozzleChange);
      
      IF (changerPlace < 1) OR (changerPlace > nC.svNrOfPlaces) THEN
         RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 18, 0, "Ecotalk.NC_NOZZLE_IN_PLACE", STR(iLine), "NC_NOZZLE_IN_PLACE", "changerPlace");
         elem.kin.ErrorReaction(TRUE);
      END_IF;
      
      IF nC.svChangerPlaces[changerPlace].mOccupied
         AND (nC.svChangerPlaces[changerPlace].iNozzleNr = nC.nextNozzleNr)
         AND nC.svChangerPlaces[changerPlace].mOK
      THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END_IF;
      
   END_IF;
   
   RETURN FALSE;
   
END_ROUTINE


ROUTINE NC_ERROR_NOZZLE_CHANGE(errorCase : NC_ErrorCase) GLOBAL USER { macro="NC" | enable="_system.gRcuFocusedRobot.nozzleChange.hasNozzleChangeBool" }
   
   VAR
      iLine : DINT;
      elem  : TRcuKinListElem; // element with the kinematicreference
      info  : TUserProgStackInfo;
      nC    : MAPTO TRcuNozzleChange;
   END_VAR
   
   IF RcData.CheckKin(elem, "NC_ERROR_NOZZLE_CHANGE") THEN
      
      // Get Line of Teachprog for Error-Msg
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
            iLine := info.lineNrs[info.depth-1]; 
         ELSE
            iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      STOPPOINT();
      
      nC := MAP(PaintRobot[elem.kin.kinListInx].nozzleChange);
      
      IF (errorCase = NoPlaceToStore) THEN
         RcuSetMessageOnce(EcoTalk_ErrNoPlaceToStore, elem.kin.kinListInx, 1, 0, "Ecotalk.NC_ERROR_NOZZLE_CHANGE", STR(iLine));
      ELSIF (errorCase = NoNozzleToTake) THEN
         RcuSetMessageOnce(EcoTalk_ErrNoNozzleToTake, elem.kin.kinListInx, 1, 0, "Ecotalk.NC_ERROR_NOZZLE_CHANGE", STR(iLine));
      END_IF;
      
   END_IF;
   
END_ROUTINE


ROUTINE NC_UNLOCK_BOLT(changerPlace : DINT) GLOBAL USER { macro="NC" | enable="_system.gRcuFocusedRobot.nozzleChange.hasNozzleChangeBool" }
   
   VAR
      iLine   : DINT;
      elem    : TRcuKinListElem; // element with the kinematicreference
      info    : TUserProgStackInfo;
      nC      : MAPTO TRcuNozzleChange;
      timeout : BOOL;
   END_VAR
   
   IF RcData.CheckKin(elem, "NC_UNLOCK_BOLT") THEN
      
      // Get Line of Teachprog for Error-Msg
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
            iLine := info.lineNrs[info.depth-1]; 
         ELSE
            iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      STOPPOINT();
      
      nC := MAP(PaintRobot[elem.kin.kinListInx].nozzleChange);
      
      IF (changerPlace < 1) OR (changerPlace > nC.svNrOfPlaces) THEN
         RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 19, 0, "Ecotalk.NC_UNLOCK_BOLT", STR(iLine), "NC_UNLOCK_BOLT", "changerPlace");
         elem.kin.ErrorReaction(TRUE);
      END_IF;
      
      nC.svChangerPlaces[changerPlace].mValveSet := TRUE;
      SysTimerSet(5000, timeout);
      WAIT (nC.svChangerPlaces[changerPlace].mValveAct = TRUE) OR timeout;
      IF timeout THEN
         RcuSetMessageOnce(EcoTalk_ErrValveNotSwitched, elem.kin.kinListInx, 1, 0, "Ecotalk.NC_UNLOCK_BOLT", STR(iLine));
         elem.kin.ErrorReaction(TRUE);
         timeout := FALSE;
      END_IF;
      
   END_IF;
   
END_ROUTINE


ROUTINE NC_LOCK_BOLT(changerPlace : DINT) GLOBAL USER { macro="NC" | enable="_system.gRcuFocusedRobot.nozzleChange.hasNozzleChangeBool" }
   
   VAR
      iLine   : DINT;
      elem    : TRcuKinListElem; // element with the kinematicreference
      info    : TUserProgStackInfo;
      nC      : MAPTO TRcuNozzleChange;
      timeout : BOOL;
   END_VAR
   
   IF RcData.CheckKin(elem, "NC_LOCK_BOLT") THEN
      
      // Get Line of Teachprog for Error-Msg
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
            iLine := info.lineNrs[info.depth-1]; 
         ELSE
            iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      STOPPOINT();
      
      nC := MAP(PaintRobot[elem.kin.kinListInx].nozzleChange);
      
      IF (changerPlace < 1) OR (changerPlace > nC.svNrOfPlaces) THEN
         RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 20, 0, "Ecotalk.NC_LOCK_BOLT", STR(iLine), "NC_LOCK_BOLT", "changerPlace");
         elem.kin.ErrorReaction(TRUE);
      END_IF;
      
      nC.svChangerPlaces[changerPlace].mValveSet := FALSE;
      SysTimerSet(5000, timeout);
      WAIT (nC.svChangerPlaces[changerPlace].mValveAct = FALSE) OR timeout;
      IF timeout THEN
         RcuSetMessageOnce(EcoTalk_ErrValveNotSwitched, elem.kin.kinListInx, 2, 0, "Ecotalk.NC_LOCK_BOLT", STR(iLine));
         elem.kin.ErrorReaction(TRUE);
         timeout := FALSE;
      END_IF;
      
   END_IF;
   
END_ROUTINE


ROUTINE NC_CHECK_NOZZLE_STORED(changerPlace : DINT) GLOBAL USER { macro="NC" | enable="_system.gRcuFocusedRobot.nozzleChange.hasNozzleChangeBool" }
   
   VAR
      iLine : DINT;
      elem  : TRcuKinListElem; // element with the kinematicreference
      info  : TUserProgStackInfo;
      nC    : MAPTO TRcuNozzleChange;
   END_VAR
   
   IF RcData.CheckKin(elem, "NC_CHECK_NOZZLE_STORED") THEN
      
      // Get Line of Teachprog for Error-Msg
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
            iLine := info.lineNrs[info.depth-1]; 
         ELSE
            iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      STOPPOINT();
      
      nC := MAP(PaintRobot[elem.kin.kinListInx].nozzleChange);
      
      IF (changerPlace < 1) OR (changerPlace > nC.svNrOfPlaces) THEN
         RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 21, 0, "Ecotalk.NC_CHECK_NOZZLE_STORED", STR(iLine), "NC_CHECK_NOZZLE_STORED", "changerPlace");
         elem.kin.ErrorReaction(TRUE);
      END_IF;
      
      IF NOT nC.svChangerPlaces[changerPlace].mOccupied THEN // storage unsuccessful
         RcuSetMessageOnce(EcoTalk_ErrStorageFailed, elem.kin.kinListInx, 1, 0, "Ecotalk.NC_CHECK_NOZZLE_STORED", STR(iLine));
      END_IF;
      
   END_IF;
   
END_ROUTINE


ROUTINE NC_CHECK_NOZZLE_TAKEN(changerPlace : DINT) GLOBAL USER { macro="NC" | enable="_system.gRcuFocusedRobot.nozzleChange.hasNozzleChangeBool" }
   
   VAR
      iLine : DINT;
      elem  : TRcuKinListElem; // element with the kinematicreference
      info  : TUserProgStackInfo;
      nC    : MAPTO TRcuNozzleChange;
   END_VAR
   
   IF RcData.CheckKin(elem, "NC_CHECK_NOZZLE_TAKEN") THEN
      
      // Get Line of Teachprog for Error-Msg
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
            iLine := info.lineNrs[info.depth-1]; 
         ELSE
            iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      STOPPOINT();
      
      nC := MAP(PaintRobot[elem.kin.kinListInx].nozzleChange);
      
      IF (changerPlace < 1) OR (changerPlace > nC.svNrOfPlaces) THEN
         RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 22, 0, "Ecotalk.NC_CHECK_NOZZLE_TAKEN", STR(iLine), "NC_CHECK_NOZZLE_TAKEN", "changerPlace");
         elem.kin.ErrorReaction(TRUE);
      END_IF;
      
      IF nC.svChangerPlaces[changerPlace].mOccupied THEN // taking unsuccessful
         RcuSetMessageOnce(EcoTalk_ErrTakingFailed, elem.kin.kinListInx, 1, 0, "Ecotalk.NC_CHECK_NOZZLE_TAKEN", STR(iLine));
      END_IF;
      
   END_IF;
   
END_ROUTINE


ROUTINE NC_PURGE_REQUIRED() : BOOL GLOBAL USER { macro="NC" | enable="_system.gRcuFocusedRobot.nozzleChange.hasNozzleChangeBool" }
   
   VAR
      iLine : DINT;
      elem  : TRcuKinListElem; // element with the kinematicreference
      info  : TUserProgStackInfo;
      nC    : MAPTO TRcuNozzleChange;
   END_VAR
   
   IF RcData.CheckKin(elem, "NC_PURGE_REQUIRED") THEN
      
      // Get Line of Teachprog for Error-Msg
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
            iLine := info.lineNrs[info.depth-1]; 
         ELSE
            iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      STOPPOINT();
      
      nC := MAP(PaintRobot[elem.kin.kinListInx].nozzleChange);
      
      IF nC.svPurgeRequired THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END_IF;
      
   END_IF;
   
   RETURN FALSE;
   
END_ROUTINE


ROUTINE NC_SET_BLOWAIR(switch : NC_Switch) GLOBAL USER { macro="NC" | enable="_system.gRcuFocusedRobot.nozzleChange.hasNozzleChangeBool" }
   
   VAR
      iLine : DINT;
      elem  : TRcuKinListElem; // element with the kinematicreference
      info  : TUserProgStackInfo;
      nC    : MAPTO TRcuNozzleChange;
   END_VAR
   
   IF RcData.CheckKin(elem, "NC_SET_BLOWAIR") THEN
      
      // Get Line of Teachprog for Error-Msg
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
            iLine := info.lineNrs[info.depth-1]; 
         ELSE
            iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      STOPPOINT();
      
      nC := MAP(PaintRobot[elem.kin.kinListInx].nozzleChange);
      
      IF switch = AirOn THEN
         nC.svSetBlowAir := TRUE;
      ELSE
         nC.svSetBlowAir := FALSE;
      END_IF;
      
   END_IF;
   
END_ROUTINE


ROUTINE NC_DOOR_OPENED() : BOOL GLOBAL USER { macro="NC" | enable="_system.gRcuFocusedRobot.nozzleChange.hasNozzleChangeBool" }
   
   VAR
      iLine : DINT;
      elem  : TRcuKinListElem; // element with the kinematicreference
      info  : TUserProgStackInfo;
      nC    : MAPTO TRcuNozzleChange;
   END_VAR
   
   IF RcData.CheckKin(elem, "NC_DOOR_OPENED") THEN
      
      // Get Line of Teachprog for Error-Msg
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
            iLine := info.lineNrs[info.depth-1]; 
         ELSE
            iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      STOPPOINT();
      
      nC := MAP(PaintRobot[elem.kin.kinListInx].nozzleChange);
      
      IF nC.svEntranceRequest THEN
         nC.svAckEntranceRequest := TRUE;
         WAIT NOT nC.svEntranceRequest;
         nC.svAckEntranceRequest := FALSE;
      END_IF;
      
      IF nC.svMainNeedles[nC.nextMainNeedle].mDoorOpened THEN
         nC.svMainNeedles[nC.nextMainNeedle].mDoorOpened := FALSE;
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END_IF;
      
   END_IF;
   
   RETURN FALSE;
   
END_ROUTINE


ROUTINE NC_SET_NOZZLE_STATE(mainNeedle : DINT; state : NC_State) GLOBAL USER { macro="NC" | enable="_system.gRcuFocusedRobot.nozzleChange.hasNozzleChangeBool" }
   
   VAR
      iLine : DINT;
      elem  : TRcuKinListElem; // element with the kinematicreference
      info  : TUserProgStackInfo;
      nC    : MAPTO TRcuNozzleChange;
   END_VAR
   
   IF RcData.CheckKin(elem, "NC_SET_NOZZLE_STATE") THEN
      
      // Get Line of Teachprog for Error-Msg
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
            iLine := info.lineNrs[info.depth-1]; 
         ELSE
            iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      STOPPOINT();
      
      nC := MAP(PaintRobot[elem.kin.kinListInx].nozzleChange);
      
      IF (mainNeedle < 1) OR (mainNeedle > 3) THEN
         RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 23, 0, "Ecotalk.NC_SET_NOZZLE_STATE", STR(iLine), "NC_SET_NOZZLE_STATE", "mainNeedle");
         elem.kin.ErrorReaction(TRUE);
      END_IF;
      
      IF state = StateOK THEN
         nC.svMainNeedles[mainNeedle].mOK := TRUE;
      ELSE
         nC.svMainNeedles[mainNeedle].mOK := FALSE;
      END_IF;
      
   END_IF;
   
END_ROUTINE


ROUTINE NC_GET_NOZZLE_NR(mainNeedle : DINT) : INT GLOBAL USER { macro="NC" | enable="_system.gRcuFocusedRobot.nozzleChange.hasNozzleChangeBool" }
   
   VAR
      iLine : DINT;
      elem  : TRcuKinListElem; // element with the kinematicreference
      info  : TUserProgStackInfo;
      nC    : MAPTO TRcuNozzleChange;
   END_VAR
   
   IF RcData.CheckKin(elem, "NC_GET_NOZZLE_NR") THEN
      
      // Get Line of Teachprog for Error-Msg
      IF GetUserProgCallStackInfo(0, info) THEN
         IF info.depth > 0 THEN
            iLine := info.lineNrs[info.depth-1]; 
         ELSE
            iLine := info.lineNrs[0]; 
         END_IF;
      END_IF;
      
      STOPPOINT();
      
      nC := MAP(PaintRobot[elem.kin.kinListInx].nozzleChange);
      
      IF (mainNeedle < 1) OR (mainNeedle > 3) THEN
         RcuSetMessageOnce(EcoTalk_ErrParamOutOfRange, elem.kin.kinListInx, 24, 0, "Ecotalk.NC_GET_NOZZLE_NR", STR(iLine), "NC_GET_NOZZLE_NR", "mainNeedle");
         elem.kin.ErrorReaction(TRUE);
      END_IF;
      
      RETURN nC.svMainNeedles[mainNeedle].iNozzleNr;
      
   END_IF;
   
   RETURN -1;
   
END_ROUTINE

(******************************************************************************************************************
****************** End of Group NC (Nozzle Change) in Teachview - menu ********************************************
******************************************************************************************************************)

